<!-- templates/leasing_pipeline.html -->
{% extends "base.html" %}
{% block content %}

<!-- Hero Banner -->
<header class="masthead" style="background-image: url('{{ url_for('static', filename='assets/img/home-bg3.jpg') }}')">
  <div class="container position-relative px-4 px-lg-5">
    <div class="row gx-4 gx-lg-5 justify-content-center">
      <div class="col-md-10 col-lg-8 col-xl-7">
        <div class="site-heading">
          <h1>Leasing Forecast Automation</h1>
          <span class="subheading">Python + SQL + Excel = Fully Integrated Rent Forecasts</span>
        </div>
      </div>
    </div>
  </div>
</header>

<!-- Main Content -->
<main class="container px-4 px-lg-5 mt-5">
  <div class="row gx-4 gx-lg-5 justify-content-center">
    <div class="col-md-12 col-lg-12 col-xl-10">

      <!-- Executive Summary -->
      <section id="exec-summary" class="mb-5">
        <h2>💼 Executive Summary</h2>
          <p>
            This solution automates leasing budget forecasting across 800+ tenants and 100+ commercial properties.
            It bridges <strong>Yardi data</strong>, <strong>Excel inputs</strong>, and <strong>Python processing</strong> to generate
            a 5–7 year outlook for base rent, vacancy, and GLA — fully integrated into a dynamic Excel workbook.
          </p>
        <ul>
          <li><strong>Portfolio:</strong> Office, Retail, Industrial properties</li>
          <li><strong>Forecasting Horizon:</strong> 2025 to 2029</li>
          <li><strong>Tools:</strong> Excel, Python (pandas, xlwings), SQL (Athena), SharePoint, Task Scheduler</li>
          <li><strong>Output:</strong> Excel workbook with dynamic projections, rent roll validations, and summary reports</li>
        </ul>
      </section>

  <section id="table-of-contents">
  <h3>📌 Table of Contents</h3>
  <ul>
    <li><a href="#exec-summary">Executive Summary</a></li>
    <li><a href="#business-impact">Business Impact</a></li>
    <li><a href="#leasing-flow">Simplified Leasing Flow</a></li>
    <li><a href="#automation">Leasing Automation in Action</a></li>
    <li><a href="#input-output">From Input to Output</a></li>
    <li><a href="#rent-trends">Net Rent Trends</a></li>
    <li><a href="#pipeline">Leasing Pipeline Overview</a></li>
    <li><a href="#architecture">Dataflow Architecture</a></li>
    <li><a href="#tech-flow">Technical Flow</a></li>
    <li><a href="#walkthrough">Full Walkthrough</a></li>
    <li><a href="#python modules">Python Modules</a></li>
    <li><a href="#challenges">Challenges Resolved</a></li>
    <li><a href="#reflections">Reflections</a></li>
  </ul>
</section>

<!-- Business Impact -->
      <section id="business-impact" class="mb-5">
        <h2>📈 Business Impact</h2>
        <ul>
          <li>✅ Replaced manual workbooks with automated Python logic</li>
          <li>⚡ <strong><span style="background-color: #fff3cd; color: #856404; padding: 3px 8px; border-radius: 5px;">⏱️ Reduced from 3 days to 10 minutes</span></strong></li>
          <li>🔍 Created a single source of truth for all leasing assumptions</li>
          <li>🧾 Enabled quick summary generation for budget sign-off</li>
        </ul>
      </section>


<!-- Simplified Leasing Flow -->
      <section id="leasing-flow" class="mb-5">
        <h3 class="mb-3"><i class="fas fa-route text-info"></i> Simplified Leasing Flow</h3>
        <p>This diagram provides a high-level overview of the leasing process used to generate projections from multiple data sources.</p>
        <div class="text-center mt-3 mb-3">
          <img src="{{ url_for('static', filename='assets/img/leasing_diagram.png') }}"
               alt="Simplified Leasing Flow"
               class="img-fluid shadow-sm"
               style="max-width: 850px;">
        </div>
      <p>🔄 This diagram outlines how leasing data flows from raw Yardi exports and team assumptions through Python logic into monthly rent projections, vacancy tracking, and Excel reports — all fully automated.</p>
      </section>

<!-- Animated Process GIF -->
<section id="automation" class="mb-5">
  <h3 class="mb-3"><i class="fas fa-play-circle text-success"></i> Leasing Automation in Action</h3>
  <p>This animation walks through the 6-step leasing forecast pipeline — from pulling in-place leases from Yardi to auto-generating Excel dashboards.</p>
  <div class="text-center">
    <img src="{{ url_for('static', filename='assets/img/leasing_sequence.gif') }}"
         alt="Animated Leasing Pipeline"
         class="img-fluid shadow-sm"
         style="max-width: 1000px;">
  </div>
        <p class="fst-italic mt-2 text-muted">
  ① SQL pull → ② Leasing inputs → ③ Python logic → ④ Writeback → ⑤ Power Query → ⑥ Dashboard output
</p>
</section>


<!-- From Input to Output -->
      <section id="input-output" class="mb-5">
        <h2><i class="fas fa-chart-line text-success"></i>📝 From Input to Output</h2>
        <p>Below are examples of how leasing team assumptions entered in Excel (purple fields) directly impact summary reports. After updating assumptions, simply run the Python script and click <strong>Refresh All</strong> in Excel to instantly generate updated visuals:</p>
        <h4 class="mt-4">🔧 Leasing Inputs (Editable Fields)</h4>
        <div class="text-center mb-4">
          <img src="{{ url_for('static', filename='assets/img/leasing_inputs_example.png') }}"
               alt="Leasing Input Tab"
               class="img-fluid shadow-sm"
               style="max-width: 1000px;">
        </div>
        <p>✏️ Leasing assumptions are entered here — including lease start/end dates, rates, and incentives — which directly drive downstream rent projections and KPIs.</p>

        <h4 id="rent-trends" class="mt-4">📊 Net Rent Comparison (2024F vs 2025B)</h4>
        <div class="text-center mb-4">
          <img src="{{ url_for('static', filename='assets/img/net_rent_summary.png') }}"
               alt="Net Rent Summary"
               class="img-fluid shadow-sm"
               style="max-width: 900px;">
        </div>

        <h4 class="mt-4">📈 Yearly Net Rent Trend (2023–2029)</h4>
        <div class="text-center mb-4">
          <img src="{{ url_for('static', filename='assets/img/net_rent_7yr_trend.png') }}"
               alt="7 Year Net Rent Trend"
               class="img-fluid shadow-sm"
               style="max-width: 1100px;">
        </div>

        <p>📌 These visuals help validate budget assumptions and explain key variances across time, asset class, and tenant level — making sign-off faster and more accurate.</p>
      </section>

      <!-- Leasing Pipeline Overview -->
      <section id="pipeline" class="mb-5">
        <h2><i class="fas fa-brain text-danger"></i>📊 Leasing Pipeline Overview</h2>
        <p class="lead">Explore how data flows from our Yardi systems through Excel and Python automation pipelines.</p>
      </section>


<!-- Dataflow Architecture -->
      <section id="architecture" class="mb-5">
        <h3 class="mb-3 ps-3">
          <i class="fas fa-network-wired text-primary"></i>📈 Dataflow Architecture (Detail)
        </h3>
        <p class="ps-3">This visual summarizes the full-stack integration across systems:</p>

        <div class="text-center" style="padding-left: 5%;">
          <img src="{{ url_for('static', filename='assets/img/leasing_architecture.png') }}"
               alt="Leasing Data Architecture"
               style="width: 150%; max-width: 1600px; display: inline-block;"
               class="shadow-sm">
        </div>
      </section>

      <!-- Technical Flow -->
      <section id="tech-flow" class="mb-5">
        <h2><i class="fas fa-cogs"></i> Technical Flow</h2>
        <ol>
          <li><strong>SQL Data Pull:</strong> Extracts 4 core tables from 1,000+ via Athena, including historical and future rent rolls</li>
          <li><strong>Load to Excel:</strong> Results populate <code>7yrBaseRent</code>, <code>RentRoll</code>, and <code>Sqft</code> tabs</li>
          <li><strong>Read via xlwings:</strong> Python loads both Yardi data and leasing inputs from <code>Inputs</code> tab</li>
          <li><strong>DataFrame Logic:</strong>
            <ul>
              <li>Combine Yardi leases + leasing team assumptions</li>
              <li>Unnest each row into monthly charges (2023–2029)</li>
              <li>Inject free rent as negative entries</li>
              <li>Amortize TI, LC, admin fees across term</li>
              <li>Calculate NER at tenant and property level</li>
            </ul>
          </li>
          <li><strong>Vacancy Integration:</strong> Identify unoccupied months by comparing against a unit-level GLA baseline</li>
          <li><strong>Output to Excel:</strong> Write to <code>all_unnest</code>, <code>GLA_Month</code>, and <code>Summary Report</code></li>
          <li><strong>Validation:</strong> Merge with rent roll to detect mismatch</li>
          <li><strong>Backup:</strong> Archive <code>Inputs</code> and validation data daily via SharePoint</li>
        </ol>
      </section>

      <!-- Full Walkthrough -->
      <section id="walkthrough" class="mb-5">
        <h2>🔍 Full Walkthrough: From Raw Data to Instant Rent Forecasts</h2>
        <p>This section walks through how the leasing budget automation works behind the scenes — from SQL to Excel to Python — and shows real code examples for each part of the pipeline.</p>

        <h4 class="mt-4 text-primary">1. 🔄 SQL Data Extraction</h4>
        <pre><code class="language-sql">
    -- extract 7 year in-place lease data
    WITH dates AS (
    SELECT CAST('2023-1-1' AS DATE) AS effect_date
    ),

    aa AS (
        SELECT *,
            un.scode as unit_no,
            round((unit_sqft * yearlyrate / 12),2) AS monthamount
        FROM (
            SELECT
                p.scode as property_code,
                cr.hunit as unit_code,
                cr.dcontractarea as unit_sqft,
                t.slastname as tenant_name,
                t.scode as tenant_code,
                COALESCE(t.dtleasefrom, t.dtmovein) as lease_from,
                COALESCE(t.dtmoveout , t.dtleaseto) as lease_to,
                cr.dtfrom as charge_from,
                cr.dtto as charge_to,
                ct.sname as charge_code,
                round(cr.dmonthlyamount*12/NULLIF(cr.dcontractarea,0),2) as yearlyrate,
                cr.hamendment,
                cr.hunit as dummy,
                cr.dadminpercent/100 as admin_fee,
                CASE WHEN cr.hchargecode = 70 THEN 'gross' ELSE 'net' END AS net_gross,
                d.effect_date
            FROM yardi.camrule cr
            JOIN yardi.tenant t ON t.hmyperson = cr.htenant
            JOIN yardi.property p ON p.hmy = t.hproperty
            left JOIN yardi.attributes a ON p.scode = a.scode AND a.subgroup1 = 'IPP Core'
            JOIN yardi.listprop l ON l.hproperty = t.hproperty
            LEFT JOIN yardi.unit un ON un.hmy = cr.hunit
            LEFT JOIN yardi.chargtyp ct ON cr.hchargecode = ct.hmy
            CROSS JOIN dates d
            WHERE
                l.hproplist in (592, 597)
                AND p.itypecommercial =1
                AND cr.hchargecode in (59,60,61,70,62,63,64)
                AND (CAST(cr.dtto AS DATE) >= d.effect_date OR cr.dtto is null)
                AND (cr.dtto IS NULL OR CAST(cr.dtto AS DATE) > CAST(cr.dtfrom AS DATE)) -- any rows with dtto being null should be included
                --AND t.hproperty in (4518)
        ) xx ;
        </code></pre>

        <h4 class="mt-4 text-primary">2. 📥 Load Queried Data into Excel</h4>
        <ul>
          <li><code>7yrBaseRent</code></li>
          <li><code>RentRoll</code></li>
          <li><code>Sqft</code></li>
          <li><code>Inputs</code> (for leasing assumptions)</li>
        </ul>

        <h4 class="mt-4 text-primary">3. 📊 Read Excel via xlwings</h4>
        <pre><code class="language-python">
def load_and_combine_tables(wb):
    df_base = pd.read_excel(wb.fullname, sheet_name='7yrBaseRent')
    df_input = pd.read_excel(wb.fullname, sheet_name='Inputs')
    return pd.concat([df_base, df_input], ignore_index=True)
        </code></pre>

        <h4 class="mt-4 text-primary">4. 🧮 Unnest Charges Over Time</h4>
        <pre><code class="language-python">
def unnest_charges(df, wb):
    df_expanded = []
    for _, row in df.iterrows():
        for month in pd.date_range(row['start_date'], row['end_date'], freq='MS'):
            rent = row['yearly_rate'] / 12
            if month in row['free_rent_months']:
                rent = 0
            df_expanded.append({**row, 'month': month, 'monthly_rent': rent})
    return pd.DataFrame(df_expanded)
        </code></pre>

        <h4 class="mt-4 text-primary">5. 🏚 Vacancy Detection</h4>
        <pre><code class="language-python">
def integrate_vacancy(df, wb, all_months):
    df_sqft = pd.read_excel(wb.fullname, sheet_name='Sqft')
    df['is_vacant'] = ~df.apply(
        lambda row: (row['unit_no'], row['month']) in
        df_sqft[['unit_no', 'month']].itertuples(index=False),
        axis=1
    )
    return df
        </code></pre>

        <h4 class="mt-4 text-primary">6. 💾 Output to Excel</h4>
        <pre><code class="language-python">
sheet = wb.sheets['all_unnest']
sheet.range("A2").value = df_final
        </code></pre>

        <h4 class="mt-4 text-primary">7. 🧾 Validation</h4>
        <pre><code class="language-python">
def update_status_with_rent_roll_and_inputs(wb):
    rentroll = pd.read_excel(wb.fullname, sheet_name='RentRoll')
    status = df_final.merge(rentroll, on='unit_no', how='left', suffixes=('', '_actual'))
    status['discrepancy'] = status['monthly_rent'] != status['monthly_rent_actual']
    return status
        </code></pre>

        <h4 class="mt-4 text-primary">8. 🔁 Backup and Refresh</h4>
        <p>Backups of inputs and summary reports are archived daily to SharePoint using Windows Task Scheduler.</p>
      </section>

      <!-- Python Modules -->
      <section id="python modules" class="mb-5">
        <h2>🧪 Python Modules</h2>
        <ul>
          <li><code>load_and_combine_tables(wb)</code>: Merges 7yrBaseRent + Inputs + Free Rent logic
          def load_and_combine_tables(wb):
    all_charges_sheet = wb.sheets["7yrBaseRent"]
    all_charges_range = all_charges_sheet.range("A1").expand()
    all_charges_df = all_charges_range.options(pd.DataFrame, header=1, index=False).value
    all_charges_df['Source'] = 'yardi'  # Add a source column for Yardi data

    # Convert 'unit_no' to string format only if it's not null
    all_charges_df['unit_no'] = all_charges_df['unit_no'].apply(lambda x: "'" + str(x) if pd.notna(x) else x)
    # Remove rows where 'unit_no' is None or just a single quote
    all_charges_df = all_charges_df[all_charges_df['unit_no'].str.strip("'").notna() & (all_charges_df['unit_no'].str.strip("'") != "")]

    inputs_sheet = wb.sheets["Inputs"]
    inputs_range = inputs_sheet.range("S27:AL3000")
    inputs_df = inputs_range.options(pd.DataFrame, header=1, index=False).value
    inputs_df['Source'] = 'inputs'  # Add a source column for Inputs data

    # Similarly convert 'unit_no' and filter
    inputs_df['unit_no'] = inputs_df['unit_no'].apply(lambda x: "'" + str(x) if pd.notna(x) else x)
    inputs_df = inputs_df[inputs_df['unit_no'].str.strip("'").notna() & (inputs_df['unit_no'].str.strip("'") != "")]</li>

          <li><code>unnest_charges(df1, wb)</code>: Generates monthly rows across 2023–2029
          def unnest_charges(df1, wb):
    global start_date, end_date, all_months  # Access global variables directly
    df_final = df1.copy()

 # Ensure all unit_no entries are strings and filter out rows with None or empty unit_no
    df_final['unit_no'] = df_final['unit_no'].astype(str)
    df_final = df_final[df_final['unit_no'].notna() & (df_final['unit_no'] != '')]

    for month_end in all_months:
        df_final[month_end.strftime('%Y-%m-%d')] = np.nan

    for index, row in df_final.iterrows():
        if pd.notna(row['yearlyrate']) and pd.notna(row['unit_sqft']):
            charge_from = max(pd.Timestamp(row['charge_from']), start_date) if pd.notna(row['charge_from']) else start_date
            charge_to = min(pd.Timestamp(row['charge_to']), end_date) if pd.notna(row['charge_to']) else end_date

            for month in all_months:
                month_start = month.to_timestamp(how='start')
                month_end = month.to_timestamp(how='end')

                if charge_from <= month_end and charge_to >= month_start:
                    days_in_month = month_end.day
                    covered_days = (min(charge_to, month_end) - max(charge_from, month_start) + pd.Timedelta(days=1)).days
                    monthly_rate = row['yearlyrate'] * row['unit_sqft'] / 12</li>

          <li><code>integrate_vacancy(df_final, wb, all_months)</code>: Adds vacant months per GLA
          def integrate_vacancy(df_final, wb, all_months):
    # Load the 'sqft' table which contains the full inventory of units
    sqft_sheet = wb.sheets['sqft']
    sqft_range = sqft_sheet.range('A1').expand()
    sqft_df = sqft_range.options(pd.DataFrame, header=1, index=False).value

    # Convert 'unit_no' to string to avoid Excel date conversion
    sqft_df['unit_no'] = "'" + sqft_df['unit_no'].astype(str)

    # Prepare a list to hold all unit entries
    unit_entries = []

    # Iterate through each unit in the full inventory
    for _, unit in sqft_df.iterrows():
        property_code = unit['property_code']
        unit_no = unit['unit_no']

        # Initialize a dictionary for the unit record
        unit_record = {
            'Source': 'vacancy',  # Mark source as 'vacancy'
            'property_code': property_code,
            'prop_name': None,
            'unit_no': unit_no,</li>

          <li><code>process_sqft_month(wb)</code>: Tracks unit-level sqft changes
          def process_sqft_month(wb):
    # Use global variables for start_date and end_date
    global start_date, end_date, all_months

    # Correct the frequency code and ensure all_months uses Timestamps at month end
    all_months = pd.date_range(start_date, end_date, freq='ME').strftime('%Y-%m-%d')

    # Read data from 'sqft' starting at column M
    sqft_sheet = wb.sheets['sqft']
    sqft_data_range = sqft_sheet.range('M1').expand('table')
    sqft_data_df = sqft_data_range.options(pd.DataFrame, header=1, index=False).value

    # Filter out rows with null start dates
    sqft_data_df = sqft_data_df.dropna(subset=['start_date'])

    # Sort data to ensure correct chronological order
    sqft_data_df = sqft_data_df.sort_values(by='start_date')

    # Initialize an empty list to collect data rows
    data_rows = []
    columns = ['property_code', 'unit_no', 'start_date'] + list(all_months)

    # Process each unit entry
    for _, group in sqft_data_df.groupby(['property_code', 'unit_no']):
        group = group.reset_index(drop=True)
        for idx, row in group.iterrows():
            new_row = {col: None for col in columns}
            new_row.update({'property_code': row['property_code'], 'unit_no': row['unit_no'], 'start_date': row['start_date']</li>

          <li><code>update_status_with_rent_roll_and_inputs(wb)</code>: Compares forecast vs actual</li>
        </ul>
        <p>All Excel interaction handled via <code>xlwings</code> — ensuring seamless link to open or saved workbooks.</p>
      </section>


      <!-- Challenges -->
      <section id="challenges" class="mb-5">
        <h2>🛠 Challenges Solved</h2>
        <ul>
          <li><strong>Duplicate assumptions:</strong> Detected overlap with activated leases → override logic added</li>
          <li><strong>NER skew from one-time TI:</strong> TI amortized over full term → included in per-month rent</li>
          <li><strong>Excel memory limits:</strong> Large formula-based workbook → replaced with Python calculations</li>
          <li><strong>Manual errors in rent roll match:</strong> Created full validation logic across merged keys</li>
        </ul>
      </section>

      <!-- Reflections -->
      <section id="reflections" class="mb-5">
        <h2>🔍 Reflections</h2>
        <ul>
          <li>This was not just a coding task — it redefined how leasing forecasts are created and validated</li>
          <li>Team buy-in increased as confidence in data grew</li>
          <li>Demonstrated value of domain-specific automation in Finance</li>
        </ul>
      </section>

    </div>
  </div>
</main>

{% endblock %}
