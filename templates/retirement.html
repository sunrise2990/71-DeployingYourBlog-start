{% extends 'base.html' %}

{% block title %}Retirement Planner{% endblock %}

{% block content %}
<div class="container mt-4">
  <h2 class="text-center mb-4">🧼 Retirement Planner</h2>

  <!-- ===== CALCULATE FORM (self-contained) ===== -->
  <form method="POST" action="{{ url_for('projects.retirement') }}">
    <div class="row g-3">
      {% set inputs = [
        ("Current Age", "current_age", "Your current age."),
        ("Retirement Age", "retirement_age", "The age at which you plan to retire."),
        ("Monthly Savings ($)", "annual_saving", "Your monthly savings amount before retirement."),
        ("Annual Saving Increase Rate (%)", "saving_increase_rate", "The expected yearly percentage increase in your monthly savings, accounting for raises or increased capacity."),
        ("Pre-Retire Return Rate (%)", "return_rate", "Enter your expected long-run CAGR before retirement. The deterministic line uses this rate. Monte Carlo converts it to an arithmetic mean μ = CAGR + ½·σ² (using Return Std Dev as σ) to draw yearly returns. Influences how your assets grow during working years."),
        ("Post-Retire Return Rate (%)", "return_rate_after", "Enter your expected long-run CAGR after retirement. The deterministic line uses this rate. Monte Carlo converts it to an arithmetic mean μ = CAGR + ½·σ² (using Return Std Dev as σ) to draw yearly returns. Usually lower due to conservative investment strategies."),
        ("Expected Lifespan (Age)", "lifespan", "Your estimated age until which you expect to live. Important for planning how long your assets must last."),
        ("Monthly Living Expense ($)", "monthly_living_expense", "Average monthly spending expected during retirement for living costs."),
        ("Income Tax Rate (%)", "income_tax_rate", "Your effective income tax rate applied to income."),
        ("Inflation Rate (%)", "inflation_rate", "Annual inflation rate used to adjust expenses and asset growth for future purchasing power."),
        ("Current Assets ($)", "current_assets", "Total value of your current investment and savings assets."),
        ("Living Expense Support / CPP (Monthly $)", "cpp_support", "Monthly income expected from CPP or other support reducing your living expenses during retirement."),
        ("Extended Year From (Age)", "cpp_from_age", "The age when you start receiving extended support such as CPP."),
        ("Extended Year To (Age)", "cpp_to_age", "The age until which extended support such as CPP will be received.")
      ] %}

      {% for label, name, tooltip in inputs %}
      <div class="col-md-3">
        <label class="form-label">
          {{ label }}
          {% if tooltip %}
          <span tabindex="0" data-bs-toggle="tooltip" data-bs-placement="top" title="{{ tooltip }}"
                style="cursor: pointer; color: #0d6efd; font-weight: bold;">&#9432;</span>
          {% endif %}
        </label>

        {# compute once so attributes are clean #}
        {% set step_value = '0.1' if ('rate' in name or 'inflation' in name or 'return' in name) else '1' %}
        {% set min_attr   = ' min="-999999"' if ('cpp' in name or 'liquidation' in name) else '' %}

        <input
          type="number"
          name="{{ name }}"
          class="form-control"
          step="{{ step_value }}"{{ min_attr }}
          value="{{ '0' if reset else request.form.get(name, '0') }}"
        >
      </div>
      {% endfor %}

      <!-- Asset Liquidation Amounts and Ages with tooltip -->
        {% set asset_tooltips = {
          "asset_liquidation_1": "Net cash from sale/withdrawal. At the sale age (e.g., 60) enter the AFTER-TAX, AFTER-FEES, AFTER-DEBT amount you will receive. Quick calc: price − mortgage payoff − selling costs − tax on gain = net cash (enter this).",
          "asset_liquidation_age_1": "Age you receive the proceeds for asset 1 (e.g., 60 for a property sale).",

          "asset_liquidation_2": "Net cash from asset 2 at its sale/withdrawal age (same rule as above).",
          "asset_liquidation_age_2": "Age you receive the proceeds for asset 2.",

          "asset_liquidation_3": "Net cash from asset 3 at its sale/withdrawal age (same rule as above).",
          "asset_liquidation_age_3": "Age you receive the proceeds for asset 3."
        } %}

      {% for name, tooltip in asset_tooltips.items() %}
      <div class="col-md-3">
        <label class="form-label">
          {{ name.replace('_', ' ').title() }}
          <span tabindex="0" data-bs-toggle="tooltip" data-bs-placement="top" title="{{ tooltip }}"
                style="cursor: pointer; color: #0d6efd; font-weight: bold;">&#9432;</span>
        </label>
        <input type="number" name="{{ name }}" class="form-control" step="1"
               value="{{ '0' if reset else request.form.get(name, '0') }}">
      </div>
      {% endfor %}

      <!-- Return Std Dev Dropdown with tooltip -->
      <div class="col-md-3">
        <label class="form-label">
          Return Std Dev (%)
          <span tabindex="0" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-html="true"
                title="Standard deviation measures the variability of your investment returns, representing the level of risk or volatility.<br>
                - Conservative (8%): Lower volatility, steadier returns, less chance of large losses or gains. Suitable if you prefer stability.<br>
                - Balanced (12%): Moderate volatility, a balance between risk and reward. Suitable for typical investors aiming for growth with manageable risk.<br>
                - Aggressive (18%): Higher volatility, higher chance of large gains or losses. Suitable if you are willing to take more risk for potentially higher returns.<br>
                It impacts the Monte Carlo simulation results by affecting the range and likelihood of possible future outcomes."
                style="cursor: pointer; color: #0d6efd; font-weight: bold;">&#9432;</span>
        </label>
        <select class="form-select" name="return_std">
          {% set std_options = [("Conservative (8%)", "8"), ("Balanced (12%)", "12"), ("Aggressive (18%)", "18")] %}
          {% for label, value in std_options %}
          <option value="{{ value }}" {% if return_std == value %}selected{% endif %}>{{ label }}</option>
          {% endfor %}
        </select>
      </div>

      <!-- Inflation Std Dev Dropdown -->
      <div class="col-md-3">
        <label class="form-label">
          Inflation Std Dev (%)
          <span tabindex="0" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-html="true"
                title="Represents variability in inflation. Higher values indicate more unpredictable inflation affecting your expenses."
                style="cursor: pointer; color: #0d6efd; font-weight: bold;">&#9432;</span>
        </label>
        <select class="form-select" name="inflation_std">
          {% set inf_options = [("Stable (0.5%)", "0.5"), ("Typical (1%)", "1.0"), ("Volatile (2%)", "2.0")] %}
          {% for label, value in inf_options %}
          <option value="{{ value }}" {% if inflation_std == value %}selected{% endif %}>{{ label }}</option>
          {% endfor %}
        </select>
      </div>

      <!-- Scenario Name -->
      <div class="col-md-6 mt-3">
        <label for="scenario_name_input" class="form-label">
          Scenario Name
          <span tabindex="0" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Name your retirement scenario to save it for future use."
                style="cursor: pointer; color: #0d6efd; font-weight: bold;">&#9432;</span>
        </label>
        <input type="text" id="scenario_name_input" name="scenario_name"
               class="form-control" placeholder="Enter scenario name to save" />
      </div>
    </div> <!-- /row g-3 -->



    <!-- Buttons (inside calc form) -->
    <div class="text-center mt-4">
      <button type="submit" name="action" value="calculate" class="btn btn-primary px-4">Calculate</button>
      <button type="submit" name="action" value="reset" class="btn btn-secondary px-4 ms-2">Reset</button>
      <button type="button" class="btn btn-success px-4 ms-2" onclick="triggerSaveScenario()">Save Scenario</button>
    </div>

    <!-- Load / Delete Saved Scenario -->
    <div class="col-md-6 mt-3">
      <label for="load_scenario_select" class="form-label">
        Load Saved Scenario
        <span tabindex="0" data-bs-toggle="tooltip" data-bs-placement="top"
              title="Select a saved scenario to load."
              style="cursor: pointer; color: #0d6efd; font-weight: bold;">&#9432;</span>
      </label>
      <select id="load_scenario_select" name="load_scenario_select" class="form-select">
        <option value="">-- Select Scenario --</option>
        {% for scenario in saved_scenarios %}
          <option value="{{ scenario.id }}" {% if selected_scenario_id|string == scenario.id|string %}selected{% endif %}>
            {{ scenario.scenario_name }}
          </option>
        {% endfor %}
      </select>

      <div class="mt-2">
        <button type="button" class="btn btn-info me-2" onclick="loadSelectedScenario()">Load Scenario</button>
        <button type="button" class="btn btn-danger" onclick="deleteSelectedScenario()">Delete Scenario</button>
      </div>
    </div>

    <!-- Init tooltips (safe inside this form) -->
    <script>
      var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
      var tooltipList = tooltipTriggerList.map(function (el) { return new bootstrap.Tooltip(el); });
    </script>
  </form>
  <!-- ===== END CALCULATE FORM ===== -->



        {% if result %}
        <div class="alert alert-success mt-5 text-center">
            <h4>📈 Estimated Final Asset Balance: <strong>${{ "{:,.0f}".format(result) }}</strong></h4>
            <p>assuming retirement at age {{ retirement_age }}</p>
        </div>
        {% endif %}



    {% if chart_data %}
    <div class="mt-5">
      <h5 class="text-center mb-3">📉 Asset vs. Retirement Expense</h5>
      <div id="retirement-chart" style="height: 400px;"></div>
      <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
      <script>
        (function () {
          const age              = {{ chart_data["Age"] | tojson }};
          const assetRetirement  = {{ chart_data["Asset_Retirement"] | tojson }};
          const expense          = {{ chart_data["Living_Exp_Retirement"] | tojson }};
          const withdrawalRate   = {{ chart_data["Withdrawal_Rate"] | tojson }};

          // ===== Amount ($K) axis ticks (right side), same approach as MC =====
          const vals = []
            .concat(assetRetirement || [])
            .concat(expense || [])
            .filter(v => v != null && isFinite(v))
            .map(Number);

          const maxY    = Math.max(1, ...(vals.length ? vals : [1]));
          const nTicks  = 6;
          const rawStep = maxY / nTicks;
          function niceStep(x){
            const pow  = Math.pow(10, Math.floor(Math.log10(x)));
            const n    = x / pow;
            const mult = (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10);
            return mult * pow;
          }
          const step = niceStep(rawStep);
          const tickvals = [];
          for (let t = 0; t <= maxY + 1e-9; t += step) tickvals.push(t);
          const ticktext = tickvals.map(v => `${Math.round(v/1000).toLocaleString()}K`);

          // ===== Emphasis for Withdrawal Rate =====
          const WARN_THRESHOLD = 0.05;      // 5%
          const WARN_COLOR     = '#ef4444'; // red-500
          const WR_BASE_COLOR  = 'gray';

          // Build overlay for >= threshold; keep full baseline to avoid gaps
          const wrHi = (withdrawalRate || []).map(v => (v != null && v >= WARN_THRESHOLD) ? v : null);

          const traces = [
            // Amounts on right axis
            {
              x: age, y: assetRetirement,
              type: 'scatter', mode: 'lines+markers',
              name: 'Asset – Retirement', line: { color: 'green' },
              yaxis: 'y2',
              hovertemplate: 'Age %{x}<br>$%{y:,.0f}<extra></extra>'
            },
            {
              x: age, y: expense,
              type: 'scatter', mode: 'lines+markers',
              // changed color from red -> indigo so red is free for WR warning
              name: 'Living Exp. – Retirement', line: { color: '#8B5CF6' },
              yaxis: 'y2',
              hovertemplate: 'Age %{x}<br>$%{y:,.0f}<extra></extra>'
            },

            // Withdrawal Rate – full baseline (continuous, subtle)
            {
              x: age, y: withdrawalRate,
              type: 'scatter', mode: 'lines+markers',
              name: 'Withdrawal Rate',
              line: { color: WR_BASE_COLOR, dash: 'dot', width: 2 },
              marker: { size: 5 },
              yaxis: 'y',
              legendgroup: 'wr',
              hovertemplate: 'Age %{x}<br>%{y:.1%}<extra></extra>'
            },

            // Withdrawal Rate – overlay for >= threshold (emphasized, but thinner)
            {
              x: age, y: wrHi,
              type: 'scatter', mode: 'lines+markers',
              name: 'Withdrawal Rate – ⚠ Above 5%',
              line: { color: WARN_COLOR, width: 3 },     // toned down from 4 -> 3
              marker: { size: 6, symbol: 'circle', color: WARN_COLOR },
              yaxis: 'y',
              legendgroup: 'wr',
              showlegend: false,                          // keep single legend item
              hovertemplate: 'Age %{x}<br><b>⚠ %{y:.1%}</b><extra></extra>'
            }
          ];

          const layout = {
            margin: { t: 30 },
            xaxis: { title: 'Age' },

            // LEFT axis: percentage
            yaxis: {
              title: 'Withdrawal Rate (%)',
              tickformat: '.1%',
              side: 'left',
              showgrid: false
            },

            // RIGHT axis: Amount ($K)
            yaxis2: {
              title: 'Amount ($K)',
              overlaying: 'y',
              side: 'right',
              tickvals,
              ticktext,
              gridcolor: 'rgba(0,0,0,0.05)'
            },

            // Horizontal warning line at threshold
            shapes: [{
              type: 'line',
              xref: 'x', yref: 'y',
              x0: Math.min(...age), x1: Math.max(...age),
              y0: WARN_THRESHOLD,  y1: WARN_THRESHOLD,
              line: { color: WARN_COLOR, width: 2, dash: 'dash' }
            }],
            annotations: [{
              xref: 'paper', yref: 'y',
              x: 0.01, y: WARN_THRESHOLD,
              xanchor: 'left', ay: -25, ax: 0,
              text: '⚠ 5% threshold',
              showarrow: true,
              arrowcolor: WARN_COLOR,
              font: { color: WARN_COLOR, size: 12 }
            }],

            legend: { orientation: 'h', x: 0.1, y: -0.2 }
          };

          Plotly.newPlot('retirement-chart', traces, layout, { responsive: true });
        })();
      </script>
    </div>
    {% endif %}




        {% if monte_carlo_data %}
        <div class="mt-5">
          <h5 class="text-center mb-3">🎲 Monte Carlo Simulation: Retirement Asset Range</h5>
          <div id="monte-carlo-chart" style="height: 400px;"></div>
        </div>

        <script>
        (function () {
          const ages = {{ monte_carlo_data["Age"] | tojson }};
          const p10  = {{ monte_carlo_data["Percentile_10"] | tojson }};
          const p50  = {{ monte_carlo_data["Percentile_50"] | tojson }};
          const p90  = {{ monte_carlo_data["Percentile_90"] | tojson }};

          const traces = [
            // band: 10th → 90th
            { x: ages, y: p10, connectgaps: false, fill: 'none',
              line: { color: 'rgba(0,100,200,0.2)', width: 0 },
              hoverinfo: 'skip', showlegend: false },

            { x: ages, y: p90, connectgaps: false, fill: 'tonexty',
              fillcolor: 'rgba(0,100,200,0.2)',
              line: { color: 'rgba(0,100,200,0.2)', width: 0 },
              hoverinfo: 'skip', showlegend: false },

            // median line
            { x: ages, y: p50, connectgaps: false, mode: 'lines+markers',
              name: 'Median', line: { color: 'blue' },
              hovertemplate: 'Age %{x}<br>$%{y:,.0f}<extra></extra>' }
          ];

          const layout = {};
          ensureLayout(layout, [p10, p50, p90]);
          Plotly.react('monte-carlo-chart', traces, layout, { responsive: true });

          // ---- same axis builder you used in Compare ----
          function ensureLayout(layout, seriesForAxis){
            layout.margin = { t: 30 };
            layout.xaxis  = { title: 'Age' };

            // Compute nice $K ticks for the right-side axis
            const vals = [];
            (seriesForAxis || []).forEach(arr => (arr || []).forEach(v => {
              if (v != null && isFinite(v)) vals.push(+v);
            }));
            const maxY    = Math.max(1, ...(vals.length ? vals : [1]));
            const nTicks  = 6;
            const rawStep = maxY / nTicks;

            function niceStep(x){
              const pow  = Math.pow(10, Math.floor(Math.log10(x)));
              const n    = x / pow;
              const mult = (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10);
              return mult * pow;
            }
            const step = niceStep(rawStep);

            const tickvals = [];
            for (let t = 0; t <= maxY + 1e-9; t += step) tickvals.push(t);
            const ticktext = tickvals.map(v => `${Math.round(v/1000).toLocaleString()}K`);

            layout.yaxis = {
              side: 'right',
              title: 'Projected Assets ($K)',
              tickvals,
              ticktext,
              gridcolor: 'rgba(0,0,0,0.05)'
            };

            layout.legend = { orientation: 'h', x: 0.1, y: -0.2 };
          }
        })();
        </script>
        {% endif %}




        {% if depletion_stats %}
        <div class="mt-4">
            <h6>⚠️ Depletion Risk Summary (Based on 300 Monte Carlo Simulations)</h6>
            <ul class="mb-1">
                <li><strong>{{ (depletion_stats.age_75 * 100) | round(1) }}%</strong> chance of running out of money by <strong>age 75</strong></li>
                <li><strong>{{ (depletion_stats.age_85 * 100) | round(1) }}%</strong> chance by <strong>age 85</strong></li>
                <li><strong>{{ (depletion_stats.age_90 * 100) | round(1) }}%</strong> chance by <strong>age 90</strong></li>
            </ul>
            <p class="text-muted small">
                Assumes current savings, asset, CPP, expenses, and retirement age remain fixed.
                Market returns and inflation are randomly varied in each simulation.
            </p>
        </div>
        {% endif %}



<!-- ==== Live What-If (beta) – single-request/one-jump version ==== -->
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3"></script>

<div class="card mt-4">
  <div class="card-body">
    <h5 class="card-title mb-3">⚡ Live What-If</h5>

    <!-- Top quick controls -->
    <div class="row g-3">
      <div class="col-md-4">
        <label class="form-label">Retirement Age:
          <span id="lw_age_val" class="fw-semibold">65</span>
        </label>
        <input type="range" id="lw_ret_age" class="form-range" min="55" max="75" step="1" value="65">
      </div>

      <div class="col-md-4">
        <label class="form-label">Monthly Expense ($/mo):
          <span id="lw_exp_val" class="fw-semibold">6,900</span>
        </label>
        <input type="range" id="lw_expense_mo" class="form-range" min="2000" max="20000" step="50" value="6900">
      </div>

      <div class="col-md-4">
        <label class="form-label">Post-Ret Return (%):
          <span id="lw_post_val" class="fw-semibold">6.0</span>
            <span class="help-tip" data-bs-toggle="tooltip"
        title="You enter CAGR. Monte Carlo uses an arithmetic mean μ = CAGR + 0.5·σ² (σ from Return Std Dev). The deterministic line uses the CAGR directly."></span>
        </label>
        <input type="range" id="lw_mu_post" class="form-range" min="0" max="12" step="0.1" value="6.0">
      </div>
    </div>

    <!-- Reset toolbar -->
    <div class="d-flex align-items-center gap-2 mt-2">
      <button id="lw_reset" type="button" class="btn btn-sm btn-outline-secondary">
        ⟲ Reset to form values
      </button>
      <span class="text-muted small">Restore sliders from the current inputs above.</span>
    </div>

    <!-- More controls -->
    <details class="mt-3">
      <summary class="h6 mb-2">More controls</summary>
      <div class="row g-3">
        <div class="col-md-4">
          <label class="form-label">Pre-Ret Return (%):
            <span id="lw_pre_val" class="fw-semibold">8.0</span>
            <span class="help-tip" data-bs-toggle="tooltip"
        title="You enter CAGR. Monte Carlo uses arithmetic μ = CAGR + 0.5·σ² with σ from Return Std Dev. Deterministic uses the CAGR."></span>
          </label>
          <input type="range" id="lw_mu_pre" class="form-range" min="0" max="12" step="0.1" value="8.0">
        </div>

        <div class="col-md-4">
          <label class="form-label">Monthly Savings ($/mo):
            <span id="lw_save_val" class="fw-semibold">7,100</span>
          </label>
          <input type="range" id="lw_saving_mo" class="form-range" min="0" max="20000" step="100" value="7100">
        </div>

        <div class="col-md-4">
          <label class="form-label">Current Assets ($):
            <span id="lw_assets_val" class="fw-semibold">1,000,000</span>
          </label>
          <input type="range" id="lw_assets" class="form-range" min="0" max="5000000" step="50000" value="1000000">
        </div>

        <div class="col-md-4">
          <label class="form-label">Income Tax Rate (%):
            <span id="lw_tax_val" class="fw-semibold">12.0</span>
          </label>
          <input type="range" id="lw_tax" class="form-range" min="0" max="50" step="0.5" value="12">
        </div>

        <div class="col-md-4">
          <label class="form-label">Inflation Rate (%):
            <span id="lw_infl_val" class="fw-semibold">2.0</span>
          </label>
          <input type="range" id="lw_infl" class="form-range" min="0" max="10" step="0.1" value="2.0">
        </div>

        <div class="col-md-4">
          <label class="form-label">Expected Lifespan (Age):
            <span id="lw_life_val" class="fw-semibold">84</span>
          </label>
          <input type="range" id="lw_life" class="form-range" min="70" max="105" step="1" value="84">
        </div>

        <!-- Mirrors of the top dropdowns -->
        <div class="col-md-4">
          <label class="form-label">Return Std Dev (%)
              <span class="text-muted small">(mirror)</span>
              <span class="help-tip" data-bs-toggle="tooltip"
        title="σ is the annual volatility used in Monte Carlo. The MC mean is μ = CAGR + 0.5·σ². Higher σ increases dispersion and sequence risk; deterministic stays unchanged."></span>
          </label>
          <select id="lw_ret_std" class="form-select"></select>
        </div>
        <div class="col-md-4">
          <label class="form-label">Inflation Std Dev (%) <span class="text-muted small">(mirror)</span></label>
          <select id="lw_infl_std" class="form-select"></select>
        </div>
      </div>
    </details>

    <canvas id="lw_assets_chart" class="mt-4"></canvas>
  </div>
</div>

<!-- ==== Goals (modular, optional) ==== -->
<div class="card mt-3">
  <div class="card-body">
    <details open>
      <summary class="h6 mb-3">🎯 Goals (beta) — extra expenses or inflows</summary>

      <div class="row g-2 align-items-end">
        <div class="col-md-3">
          <label class="form-label">Name</label>
          <input id="g_name" type="text" class="form-control" placeholder="college">
        </div>

        <div class="col-md-3">
          <label class="form-label">Type</label>
          <select id="g_type" class="form-select">
            <option value="expense" selected>Expense (outflow)</option>
            <option value="inflow">Inflow</option>
          </select>
        </div>

        <div class="col-md-2">
          <label class="form-label">Amount ($, today)</label>
          <input id="g_amt" type="number" class="form-control" value="30000" min="0" step="100">
        </div>

        <div class="col-md-2">
          <label class="form-label">Start age</label>
          <input id="g_age" type="number" class="form-control" value="60" min="0" step="1">
        </div>

        <div class="col-md-2">
          <label class="form-label">Recurrence</label>
          <select id="g_rec" class="form-select">
            <option value="once" selected>Once (at start age)</option>
            <option value="annual">Annual (start→end)</option>
            <option value="years">For N years</option>
          </select>
        </div>

        <div class="col-md-2 d-none" id="g_years_wrap">
          <label class="form-label">Years</label>
          <input id="g_years" type="number" class="form-control" value="4" min="1" step="1">
        </div>

        <div class="col-md-2 d-none" id="g_endage_wrap">
          <label class="form-label">End age</label>
          <input id="g_endage" type="number" class="form-control" value="84" min="0" step="1">
        </div>

        <div class="col-md-3">
          <div class="form-check mt-4">
            <input class="form-check-input" type="checkbox" id="g_infl" checked>
            <label class="form-check-label" for="g_infl">Inflation linked</label>
          </div>
        </div>

        <div class="col-md-3">
          <button id="goal_add" type="button" class="btn btn-primary mt-3">+ Add Goal</button>
        </div>
      </div>

      <hr class="my-3">

      <div class="table-responsive">
        <table class="table table-sm align-middle">
          <thead>
            <tr>
              <th style="width:70px;">Enabled</th>
              <th>Name</th>
              <th>Type</th>
              <th>When</th>
              <th class="text-end">Amount</th>
              <th>Infl.</th>
              <th style="width:70px;"></th>
            </tr>
          </thead>
          <tbody id="goal_rows"></tbody>
        </table>
      </div>

<script id="goals-module">
(() => {
  const rowsEl   = document.getElementById('goal_rows');
  const addBtn   = document.getElementById('goal_add');

  const nameEl   = document.getElementById('g_name');
  const typeEl   = document.getElementById('g_type');
  const amtEl    = document.getElementById('g_amt');
  const ageEl    = document.getElementById('g_age');
  const recEl    = document.getElementById('g_rec');
  const yearsWrap= document.getElementById('g_years_wrap');
  const yearsEl  = document.getElementById('g_years');
  const endWrap  = document.getElementById('g_endage_wrap');
  const endEl    = document.getElementById('g_endage');
  const inflEl   = document.getElementById('g_infl');

  let rows = [];
  const subs = new Set();
  const notify = () => subs.forEach(fn => { try { fn(); } catch {} });
  const onChange = fn => (subs.add(fn), () => subs.delete(fn));
  const current = () => rows.filter(r => r.enabled !== false);

  function esc(s){ return (s ?? '').toString().replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function whenText(r){
    if (r.recurrence === 'annual') return `Age ${r.start_age}–${r.end_age ?? ''}`;
    if (r.recurrence === 'years')  return `Age ${r.start_age} × ${r.years}`;
    return `At ${r.start_age}`;
  }
  function render(){
    rowsEl.innerHTML = '';
    rows.forEach((r,i) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input class="form-check-input g-en" type="checkbox" data-i="${i}" ${r.enabled !== false ? 'checked' : ''}></td>
        <td>${esc(r.name || 'Goal')}</td>
        <td>${r.is_expense ? 'Expense' : 'Inflow'}</td>
        <td>${whenText(r)}</td>
        <td class="text-end">$${(+r.amount).toLocaleString()}</td>
        <td>${r.inflation_linked ? 'Yes' : 'No'}</td>
        <td><button class="btn btn-sm btn-outline-danger g-del" data-i="${i}">×</button></td>`;
      rowsEl.appendChild(tr);
    });
  }
  function readNew(){
    return {
      enabled: true,
      name: (nameEl.value || 'Goal').trim(),
      is_expense: (typeEl.value !== 'inflow'),
      amount: +amtEl.value || 0,
      start_age: parseInt(ageEl.value, 10) || 0,
      recurrence: recEl.value,
      years: recEl.value === 'years'  ? (parseInt(yearsEl.value, 10) || 1) : undefined,
      end_age: recEl.value === 'annual' ? (parseInt(endEl.value, 10) || undefined) : undefined,
      inflation_linked: !!inflEl.checked
    };
  }

  recEl.addEventListener('change', () => {
    yearsWrap.classList.toggle('d-none', recEl.value !== 'years');
    endWrap.classList.toggle('d-none',   recEl.value !== 'annual');
  });

  addBtn.addEventListener('click', () => {
    rows.push(readNew());
    render();
    notify();
  });

  rowsEl.addEventListener('click', e => {
    const i = e.target.getAttribute('data-i');
    if (i == null) return;
    if (e.target.classList.contains('g-del')) {
      rows.splice(+i, 1);
      render();
      notify();
    }
  });
  rowsEl.addEventListener('change', e => {
    if (e.target.classList.contains('g-en')) {
      const i = +e.target.getAttribute('data-i');
      rows[i].enabled = e.target.checked;
      notify();
    }
  });

  window.GoalsModule = { current, onChange };

  // Live refresh: single ping only
  try {
    if (window.__liveTest?.ping) {
      let t;
      onChange(() => {
        clearTimeout(t);
        t = setTimeout(() => window.__liveTest.ping(), 180);
      });
    }
  } catch {}
})();
</script>

      <p class="text-muted small mb-0">
        Note: goals are merged client-side into asset liquidations (post-tax) before the live update call.
      </p>
    </details>
  </div>
</div>

<!-- 🧭 Strategy Coach (beta) -->
<div class="card mt-3">
  <div class="card-body">
    <h6 class="mb-2">🧭 Strategy Coach (beta)</h6>

    <div class="border rounded p-2 mb-3">
      <div class="row g-2 align-items-end">
        <div class="col-md-3">
          <label class="form-label mb-1">Metric</label>
          <select id="sc_metric" class="form-select form-select-sm">
            <option value="det">Deterministic</option>
            <option value="p10">MC p10</option>
            <option value="p50" selected>MC Median</option>
            <option value="p90">MC p90</option>
          </select>
        </div>

        <div class="col-md-3">
          <label class="form-label mb-1">Final assets ≥ ($)</label>
          <input id="sc_assets" type="number" class="form-control form-control-sm" value="2000000" min="0" step="10000">
        </div>

        <div class="col-md-3">
          <label class="form-label mb-1">At age</label>
          <input id="sc_age" type="number" class="form-control form-control-sm" value="90" min="60" max="105" step="1">
        </div>
      </div>

      <div class="row g-3 mt-2">
        <div class="col-md-9 sc-important">
          <div class="mb-1 sc-label-strong">Lever (choose one)</div>
          <div class="d-flex flex-wrap gap-4">
            <label class="form-check small"><input class="form-check-input" type="radio" name="sc_lever" value="retirement_age" checked> Retirement age</label>
            <label class="form-check small"><input class="form-check-input" type="radio" name="sc_lever" value="annual_expense"> Spending</label>
            <label class="form-check small"><input class="form-check-input" type="radio" name="sc_lever" value="annual_saving"> Savings</label>
            <label class="form-check small"><input class="form-check-input" type="radio" name="sc_lever" value="post_ret_return"> Post-ret return (%)</label>
          </div>
        </div>
        <!-- buttons column (Solve first) -->
        <div class="col-md-3 d-flex justify-content-end gap-2">
          <button id="sc_solve" type="button" class="btn btn-sm btn-primary">Solve</button>
          <button id="sc_clear_goals" type="button" class="btn btn-sm btn-outline-secondary">Clear coach goals</button>
        </div>
      </div>

      <div id="sc_result" class="small text-muted mt-2"></div>
    </div>

    <div id="coach_area" class="vstack gap-2"></div>
  </div>
</div>

<script>
(function () {
  // Sliders + labels
  const elAge   = document.getElementById('lw_ret_age');
  const elExpMo = document.getElementById('lw_expense_mo');
  const elPost  = document.getElementById('lw_mu_post');

  const elPre   = document.getElementById('lw_mu_pre');
  const elSaveMo= document.getElementById('lw_saving_mo');
  const elAssets= document.getElementById('lw_assets');
  const elTax   = document.getElementById('lw_tax');
  const elInfl  = document.getElementById('lw_infl');
  const elLife  = document.getElementById('lw_life');

  const ageVal   = document.getElementById('lw_age_val');
  const expVal   = document.getElementById('lw_exp_val');
  const postVal  = document.getElementById('lw_post_val');
  const preVal   = document.getElementById('lw_pre_val');
  const saveVal  = document.getElementById('lw_save_val');
  const assetsVal= document.getElementById('lw_assets_val');
  const taxVal   = document.getElementById('lw_tax_val');
  const inflVal  = document.getElementById('lw_infl_val');
  const lifeVal  = document.getElementById('lw_life_val');

  // Std dev mirror selects
  const elRetStdSel  = document.getElementById('lw_ret_std');
  const elInflStdSel = document.getElementById('lw_infl_std');

  // Strategy Coach UI
  const scMetric   = document.getElementById('sc_metric');
  const scAssets   = document.getElementById('sc_assets');
  const scAge      = document.getElementById('sc_age');
  const scSolve    = document.getElementById('sc_solve');
  const scClear    = document.getElementById('sc_clear_goals');
  const scResult   = document.getElementById('sc_result');

  const getLever = () => (document.querySelector('input[name="sc_lever"]:checked') || {}).value || 'retirement_age';
  window.__coach_goals = window.__coach_goals || [];
  const CSRF = "{{ csrf_token() if csrf_token is defined else '' }}";

  // Request/paint gating
  let __lastReqId = 0;
  let __lastPaintToken = 0;
  let __ctrl = null;
  let __awaitingSolveCommit = false;

  const $ = (sel, root=document) => root.querySelector(sel);
  function findByLabelText(text) {
    const labels = Array.from(document.querySelectorAll('label'));
    const t = (text || '').toLowerCase();
    const lab = labels.find(lb => (lb.textContent || '').toLowerCase().includes(t));
    if (!lab) return null;
    if (lab.control) return lab.control;
    const forId = lab.getAttribute('for'); if (forId) { const el = document.getElementById(forId); if (el) return el; }
    const col = lab.closest('.col-md-4, .col, .form-group, .mb-3') || lab.parentElement;
    return col ? col.querySelector('input,select,textarea') : null;
  }
  function findInput({ids=[], names=[], labelIncludes=[]}) {
    for (const id of ids)   { const el = document.getElementById(id); if (el) return el; }
    for (const nm of names) { const el = $(`[name="${nm}"]`);         if (el) return el; }
    for (const txt of labelIncludes) { const el = findByLabelText(txt); if (el) return el; }
    return null;
  }
  function numFrom(el) {
    if (!el) return NaN;
    if (el.tagName === 'SELECT') {
      const opt = el.options[el.selectedIndex]; const txt = (opt && opt.text) || el.value || '';
      const m = txt.toString().match(/[\d.]+/); return m ? Number(m[0]) : NaN;
    }
    const raw = (el.value ?? el.textContent ?? '').toString();
    return Number(raw.replace(/[^\d.\-]/g, ''));
  }
  const toDec = x => (Number.isFinite(x) ? x/100 : NaN);
  const nz = (v, f) => (Number.isFinite(v) ? v : f);
  const fmt = x => Number(x).toLocaleString();

  function gatherForm() {
    const current_age     = nz(numFrom(findInput({labelIncludes:['Current Age'], names:['current_age']})), 53);
    const retirement_age  = nz(numFrom(findInput({labelIncludes:['Retirement Age'], names:['retirement_age']})), 65);
    const life_expectancy = nz(numFrom(findInput({labelIncludes:['Expected Lifespan'], names:['expected_lifespan']})), 90);

    const ext_from = nz(numFrom(findInput({ids:['extended_year_from_age','extended_from_age'],names:['extended_year_from_age'],labelIncludes:['Extended Year From']})), retirement_age);
    const ext_to_raw = nz(numFrom(findInput({ids:['extended_year_to_age','extended_to_age'],names:['extended_year_to_age'],labelIncludes:['Extended Year To']})), life_expectancy + 1);
    const cpp_start_age = ext_from;
    const cpp_end_age   = Math.max(ext_from, (Number.isFinite(ext_to_raw) ? (ext_to_raw - 1) : life_expectancy));

    const msav = nz(numFrom(findInput({labelIncludes:['Monthly Savings'], names:['monthly_savings']})), 0);
    const annual_saving = msav * 12;

    const inc_rate_pct = nz(numFrom(findInput({labelIncludes:['Annual Saving Increase Rate'], names:['annual_saving_increase_rate']})), 0);
    const saving_increase_rate = toDec(inc_rate_pct);

    const pre_ret_pct  = nz(numFrom(findInput({labelIncludes:['Pre-Retire Return Rate'], names:['pre_retire_return_rate']})), 6);
    const post_ret_pct = nz(numFrom(findInput({labelIncludes:['Post-Retire Return Rate'], names:['post_retire_return_rate']})), 4.5);
    const return_rate        = toDec(pre_ret_pct);
    const return_rate_after  = toDec(post_ret_pct);

    const mexp  = nz(numFrom(findInput({labelIncludes:['Monthly Living Expense'], names:['monthly_living_expense','living_expense']})), 0);
    const annual_expense = mexp * 12;

    const tax_pct = nz(numFrom(findInput({labelIncludes:['Income Tax Rate'], names:['income_tax_rate']})), 15);
    const inflation_pct = nz(numFrom(findInput({labelIncludes:['Inflation Rate'], names:['inflation_rate']})), 2.5);
    const income_tax_rate = toDec(tax_pct);
    const inflation_rate  = toDec(inflation_pct);

    const current_assets = nz(numFrom(findInput({labelIncludes:['Current Assets'], names:['current_assets']})), 0);
    const cpp_monthly    = nz(numFrom(findInput({labelIncludes:['Living Expense Support','CPP'], names:['cpp_monthly','living_expense_support']})), 0);

    const ret_std_pct  = nz(numFrom(findInput({labelIncludes:['Return Std Dev'], names:['return_std_dev']})), 8);
    const infl_std_pct = nz(numFrom(findInput({labelIncludes:['Inflation Std Dev'], names:['inflation_std_dev']})), 0.5);
    const return_std   = toDec(ret_std_pct);
    const inflation_std= toDec(infl_std_pct);

    function liq(n){
      const amt = nz(numFrom(findInput({labelIncludes:[`Asset Liquidation ${n}`], names:[`asset_liquidation_${n}`]})), 0);
      const age = nz(numFrom(findInput({labelIncludes:[`Asset Liquidation Age ${n}`], names:[`asset_liquidation_age_${n}`]})), NaN);
      return (amt>0 && Number.isFinite(age)) ? {amount: amt, age: Math.round(age)} : null;
    }
    const asset_liquidations = [liq(1), liq(2), liq(3)].filter(Boolean);

    return {
      current_age, retirement_age, annual_saving, saving_increase_rate, current_assets,
      return_rate, return_rate_after, annual_expense, cpp_monthly, cpp_start_age, cpp_end_age,
      asset_liquidations, inflation_rate, life_expectancy, income_tax_rate,
      return_mean: return_rate, return_mean_after: return_rate_after,
      return_std, inflation_mean: inflation_rate, inflation_std,
    };
  }

  // Goals → liquidations
  function goalsToLiquidations(goals, base){
    const out = [], infl = base.inflation_rate || 0, currAge = base.current_age || 0;
    for (const g of goals || []) {
      if (!g || g.enabled === false) continue;
      let ages = [];
      if (g.recurrence === 'once') ages = [g.start_age];
      else if (g.recurrence === 'years')  ages = Array.from({length:Math.max(1, g.years||1)}, (_,i)=>g.start_age+i);
      else if (g.recurrence === 'annual'){ const end = (g.end_age ?? g.start_age); const n = Math.max(0, end - g.start_age + 1); ages = Array.from({length:n},(_,i)=>g.start_age+i); }
      for (const age of ages) {
        const yrs = Math.max(0, age - currAge);
        const amt = g.amount * (g.inflation_linked ? Math.pow(1 + infl, yrs) : 1);
        out.push({ age: Math.round(age), amount: g.is_expense ? -amt : amt });
      }
    }
    return out;
  }

  // Chart
  const ctx = document.getElementById('lw_assets_chart').getContext('2d');
  const chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        { label: 'Deterministic', data: [],
          borderColor: '#3b82f6', backgroundColor: 'rgba(59,130,246,0.06)',
          borderWidth: 2, pointRadius: 0, tension: 0.25 },

        { label: 'MC P10', data: [],
          borderColor: '#dc2626', backgroundColor: 'rgba(220,38,38,0.05)',
          borderWidth: 2.0, borderDash: [3,3],
          borderCapStyle: 'round',
          pointRadius: 0, tension: 0.25 },

        { label: 'MC Median', data: [],
          borderColor: '#ec4899', backgroundColor: 'rgba(236,72,153,0.08)',
          borderWidth: 3, borderDash: [8,4],
          borderCapStyle: 'round',
          pointRadius: 0, tension: 0.25 },

        { label: 'MC P90', data: [],
          borderColor: '#fbbf24', backgroundColor: 'rgba(251,191,36,0.04)',
          borderWidth: 1.7, borderDash: [4,2], pointRadius: 0, tension: 0.25 }
      ]
    },
    options: {
      responsive: true,
      animation: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed.y ?? 0;
              return `${ctx.dataset.label}: $${Math.round(v).toLocaleString()}`;
            }
          }
        }
      },
      scales: {
        x: { title: { display: true, text: 'Age' } },
        y: {
          position: 'right',
          title: { display: true, text: 'Assets (CDN $K)' },
          ticks: {
            callback: (val) => `${Math.round(Number(val)/1000).toLocaleString()}K`
          }
        }
      }
    }
  });

  // labels/sliders
  function setSlidersFromForm(f) {
    elAge.value     = f.retirement_age;
    elExpMo.value   = Math.round((f.annual_expense/12) / 50) * 50;
    elPost.value    = Math.round((f.return_rate_after * 100) * 10) / 10;
    elPre.value     = Math.round((f.return_rate * 100) * 10) / 10;
    elSaveMo.value  = Math.round((f.annual_saving/12) / 100) * 100;
    elAssets.value  = f.current_assets;
    elTax.value     = Math.round((f.income_tax_rate * 100) * 2) / 2;
    elInfl.value    = Math.round((f.inflation_rate * 100) * 10) / 10;
    elLife.value    = f.life_expectancy;
  }
  function updateLabelsFromSliders() {
    ageVal.textContent     = elAge.value;
    expVal.textContent     = fmt(elExpMo.value);
    postVal.textContent    = (+elPost.value).toFixed(1);
    preVal.textContent     = (+elPre.value).toFixed(1);
    saveVal.textContent    = fmt(elSaveMo.value);
    assetsVal.textContent  = fmt(elAssets.value);
    taxVal.textContent     = (+elTax.value).toFixed(1);
    inflVal.textContent    = (+elInfl.value).toFixed(1);
    lifeVal.textContent    = elLife.value;
  }

  // Mirror the top std-dev dropdowns into the What-If section
  function hydrateStdMirrors() {
    const topRet  = findInput({ labelIncludes:['Return Std Dev'],   names:['return_std_dev'] });
    const topInfl = findInput({ labelIncludes:['Inflation Std Dev'], names:['inflation_std_dev'] });

    function copyOptions(from, to) {
      if (!from || !to) return;
      to.innerHTML = '';
      Array.from(from.options || []).forEach((opt) => {
        const o = document.createElement('option');
        o.value = opt.value;
        o.text  = opt.text;
        to.appendChild(o);
      });
      to.selectedIndex = from.selectedIndex ?? 0;
    }

    copyOptions(topRet,  elRetStdSel);
    copyOptions(topInfl, elInflStdSel);
  }

  // init sliders & mirrors from form
  const base = gatherForm();
  setSlidersFromForm(base);
  hydrateStdMirrors();
  updateLabelsFromSliders();

// collect params — life horizon comes from the What-If slider ONLY
let lastForm = null;
function collectParams() {
  const form = gatherForm();

  // ---- slider overrides (rates set, but DON'T compute means yet) ----
  form.retirement_age    = +elAge.value;
  form.annual_expense    = (+elExpMo.value) * 12;
  form.return_rate_after = (+elPost.value) / 100;   // CAGR (post-ret)
  form.return_rate       = (+elPre.value)  / 100;   // CAGR (pre-ret)
  form.annual_saving     = (+elSaveMo.value) * 12;
  form.current_assets    = +elAssets.value;
  form.income_tax_rate   = (+elTax.value) / 100;
  form.inflation_rate    = (+elInfl.value) / 100;

  // horizon strictly from slider (solver can extend when needed)
  form.life_expectancy   = +elLife.value;

  // ---- mirror selects override std-devs HERE (before computing means) ----
  if (elRetStdSel && elRetStdSel.options.length) {
    const v = numFrom(elRetStdSel);
    if (Number.isFinite(v)) form.return_std = v / 100;      // σ (decimal)
  }
  if (elInflStdSel && elInflStdSel.options.length) {
    const v = numFrom(elInflStdSel);
    if (Number.isFinite(v)) form.inflation_std = v / 100;
  }

  // ensure σ fields are numeric
  form.return_std     = Number(form.return_std)     || 0;
  form.inflation_std  = Number(form.inflation_std)  || 0;

  // ---- compute arithmetic means from the latest σ (this was the bug) ----
  // MC uses arithmetic mean: μ = CAGR + 0.5·σ²
  const s = form.return_std;
  form.return_mean        = form.return_rate       + 0.5 * s * s;
  form.return_mean_after  = form.return_rate_after + 0.5 * s * s;

  // inflation mean mirrors its rate (we don't apply 0.5σ² to inflation)
  form.inflation_mean = form.inflation_rate;

  // Single-jump sim count
  form.num_simulations = 300;

  // goals ➜ liqs
  const goalsTable = (window.GoalsModule?.current() || []);
  const coachGoals = (window.__coach_goals || []);
  const allGoals   = goalsTable.concat(coachGoals);
  form.goal_events = allGoals;
  const fromGoals  = goalsToLiquidations(allGoals, form);
  form.asset_liquidations = [...(form.asset_liquidations || []), ...fromGoals];

  updateLabelsFromSliders();
  lastForm = form;
  return form;
}

// draw helper (order-guarded)
function drawFromData(data, startAge, paintToken){
  if (paintToken != null && paintToken < __lastPaintToken) return;
  if (paintToken != null) __lastPaintToken = paintToken;
  const n = (data.p50?.length) || (data.deterministic?.length) || 0;
  const sa = startAge ?? (lastForm?.current_age) ?? 0;
  chart.data.labels = Array.from({ length: n }, (_, i) => sa + i);
  chart.data.datasets[0].data = data.deterministic || [];
  chart.data.datasets[1].data = data.p10 || [];
  chart.data.datasets[2].data = data.p50 || [];
  chart.data.datasets[3].data = data.p90 || [];
  chart.update('none');
}

// === Single debounced FULL request (300 sims) ===
async function ping() {
  if (__awaitingSolveCommit) return;
  const payload = collectParams();
  payload.mode = 'full';
  payload.coach_prefs = null;

  const url = "{{ url_for('projects.live_update') }}";
  const myId = ++__lastReqId;
  const paintToken = ++__lastPaintToken;

  if (__ctrl) { try { __ctrl.abort(); } catch {} }
  __ctrl = new AbortController();

  const headers = { "Content-Type": "application/json" };
  if (CSRF) headers["X-CSRFToken"] = CSRF;

  try {
    const res = await fetch(url, {
      method: "POST",
      headers,
      body: JSON.stringify(payload),
      signal: __ctrl.signal
    });
    if (!res.ok) { console.error("live-update failed", res.status, await res.text()); return; }
    if (myId !== __lastReqId) return;
    const data = await res.json();
    if (myId !== __lastReqId) return;
    drawFromData(data, payload.current_age, paintToken);
    renderCoach(data.coach || []);
  } catch (e) {
    if (e?.name !== 'AbortError') console.error("live-update error", e);
  }
}
const debouncedPing = (() => { let t; return () => { clearTimeout(t); t = setTimeout(ping, 300); }; })();

// Coach UI helpers
function applyPatch(patch){
  if (!patch) return;
  if (patch.retirement_age != null) elAge.value = +patch.retirement_age;
  if (patch.annual_expense != null) elExpMo.value = Math.max(0, Math.round((+patch.annual_expense)/12/50)*50);
  if (patch.annual_saving != null) elSaveMo.value = Math.max(0, Math.round((+patch.annual_saving)/12/100)*100);
  if (patch.return_rate_after != null) {
    elPost.value = Math.round((+patch.return_rate_after * 100) * 10) / 10;
    postVal.textContent = (+elPost.value).toFixed(1);
  }
  if (Array.isArray(patch.goal_events) && patch.goal_events.length){
    window.__coach_goals = (window.__coach_goals || []).concat(patch.goal_events);
  }
  updateLabelsFromSliders();
  debouncedPing();
}
function renderCoach(list){
  const area = document.getElementById('coach_area');
  if (!area) return;
  area.innerHTML = '';
  (list || []).forEach(s => {
    const row = document.createElement('div');
    if (s.type === 'status') {
      row.className = 'alert alert-secondary py-2 mb-0';
      row.textContent = s.detail || s.title || 'Status';
    } else {
      row.className = 'd-flex justify-content-between align-items-start border rounded p-2';
      row.innerHTML = `
        <div>
          <div class="fw-semibold">${s.title || 'Suggestion'}</div>
          <div class="text-muted small">${s.why || ''}</div>
        </div>
        <div class="d-flex gap-2">
          <button type="button" class="btn btn-sm btn-primary">Try it</button>
        </div>`;
      row.querySelector('button').addEventListener('click', () => applyPatch(s.patch));
    }
    area.appendChild(row);
  });
}

// Event wiring — ONE request per change
[elAge, elExpMo, elPost, elPre, elSaveMo, elAssets, elTax, elInfl, elLife]
  .forEach(el => {
    el.addEventListener('input', debouncedPing);
    el.addEventListener('change', ping);
  });

// mirror selects: ping on change
[elRetStdSel, elInflStdSel].forEach(el => {
  if (!el) return;
  el.addEventListener('change', ping);
});

// Solver "At age" changes DO NOT mutate the slider anymore
scAge.addEventListener('input', debouncedPing);
scAge.addEventListener('change', ping);

// Solver evals — use FULL (300 sims) but DO NOT DRAW
async function evalWithOverrides(overrides){
  const payload = collectParams();
  Object.assign(payload, overrides || {});
  if (overrides && Array.isArray(overrides.goal_events)) {
    const manualLiqs = (gatherForm().asset_liquidations || []);
    const allGoals = (payload.goal_events || []);
    const fromGoals = goalsToLiquidations(allGoals, payload);
    payload.asset_liquidations = [...manualLiqs, ...fromGoals];
  }
  payload.mode = 'full';
  payload.coach_prefs = null;

  const headers = { "Content-Type": "application/json" };
  if (CSRF) headers["X-CSRFToken"] = CSRF;

  const url = "{{ url_for('projects.live_update') }}";
  const res = await fetch(url, {
    method: "POST",
    headers,
    body: JSON.stringify(payload)
  });
  const data = await res.json();
  return { data, startAge: payload.current_age };
}
function curveByMetric(data, metric){
  if (metric === 'det') return data.deterministic || [];
  if (metric === 'p10') return data.p10 || [];
  if (metric === 'p90') return data.p90 || [];
  return data.p50 || [];
}
function valueAtAge(curve, startAge, age){
  const idx = Math.max(0, Math.min(curve.length - 1, Math.round(age - startAge)));
  return Number(curve[idx] ?? 0);
}

async function commitFull(overrides, patch){
  __awaitingSolveCommit = true;
  if (__ctrl) { try { __ctrl.abort(); } catch {} }

  const payload = collectParams();
  Object.assign(payload, overrides || {});
  payload.mode = 'full';
  payload.coach_prefs = null;

  const url = "{{ url_for('projects.live_update') }}";
  const paintToken = ++__lastPaintToken;
  __ctrl = new AbortController();

  const headers = { "Content-Type": "application/json" };
  if (CSRF) headers["X-CSRFToken"] = CSRF;

  try {
    const res = await fetch(url, {
      method: "POST",
      headers,
      body: JSON.stringify(payload),
      signal: __ctrl.signal
    });
    if (!res.ok) { console.error("full-commit failed", res.status, await res.text()); return; }
    const data = await res.json();
    drawFromData(data, payload.current_age, paintToken);

    // reflect patch without firing extra pings
    if (patch) {
      if (patch.retirement_age != null) elAge.value = +patch.retirement_age;
      if (patch.annual_expense != null) elExpMo.value = Math.max(0, Math.round((+patch.annual_expense)/12/50)*50);
      if (patch.annual_saving != null)  elSaveMo.value = Math.max(0, Math.round((+patch.annual_saving)/12/100)*100);
      if (patch.return_rate_after != null) {
        elPost.value = Math.round((+patch.return_rate_after * 100) * 10) / 10;
        postVal.textContent = (+elPost.value).toFixed(1);
      }
      updateLabelsFromSliders();
    }
  } finally {
    __awaitingSolveCommit = false;
  }
}

async function solve(){
  scResult.textContent = 'Solving…';

  const metric = scMetric.value;
  const targetAssets = Math.max(0, +scAssets.value || 0);

  const lifeForm = lastForm?.life_expectancy ?? gatherForm().life_expectancy ?? 90;
  const cur      = lastForm?.current_age ?? gatherForm().current_age ?? 50;

  let targetAge = +scAge.value || lifeForm;
  targetAge = Math.max(targetAge, cur);
  targetAge = Math.min(Math.max(targetAge, (+elLife.min || 70)), (+elLife.max || 105));

  // Make What-If lifespan slider FOLLOW the Solver "At age"
  const clamp = (a, lo, hi) => Math.min(Math.max(a, lo), hi);
  const clamped = clamp(targetAge, (+elLife.min || 70), (+elLife.max || 105));

  if (+elLife.value !== clamped) {
    elLife.value = clamped;
    lifeVal.textContent = clamped;
  }
  const horizon = clamped;

  const lever = getLever();
  const bounds = {
    retirement_age: [ (+elAge.min || 55), (+elAge.max || 75) ],
    annual_expense: [ (+elExpMo.min||2000)*12, (+elExpMo.max||20000)*12 ],
    annual_saving:  [ (+elSaveMo.min||0)*12,   (+elSaveMo.max||20000)*12 ],
    post_ret_return:[ (+elPost.min||0)/100,    (+elPost.max||12)/100 ]
  };
  const increasing = { retirement_age:true, annual_expense:false, annual_saving:true, post_ret_return:true };
  const [lo0, hi0] = bounds[lever];
  const inc = increasing[lever];

  // helper: get sigma (decimal) to convert CAGR -> arithmetic mean for MC
  const getSigma = () => (lastForm?.return_std ?? gatherForm().return_std ?? 0);

  function buildOverrides(x){
    const base = { life_expectancy: horizon, num_simulations: 300 };
    if (lever === 'retirement_age') return { ...base, retirement_age: Math.round(x) };
    if (lever === 'annual_expense')  return { ...base, annual_expense: x };
    if (lever === 'annual_saving')   return { ...base, annual_saving: x };
    if (lever === 'post_ret_return') {
      const s = getSigma();               // σ as a decimal (e.g., 0.18)
      return {
        ...base,
        return_rate_after: x,             // x is the user-facing CAGR
        return_mean_after: x + 0.5 * s * s
      };
    }
    return base;
  }

  async function f(x){
    const { data, startAge } = await evalWithOverrides(buildOverrides(x));
    const curve = curveByMetric(data, metric);
    return valueAtAge(curve, startAge, targetAge) - targetAssets;
  }

  let lo = lo0, hi = hi0;
  let flo = await f(lo);
  let fhi = await f(hi);

  const maxIter = 14;
  const tolX = (lever==='retirement_age') ? 0.25
           : (lever==='post_ret_return') ? 0.0005
           : 50;
  const tolF = 500;

  let feasible = false;
  if (inc) { feasible = !(fhi < 0); if (flo >= 0) { hi = lo; fhi = flo; } }
  else     { feasible = !(flo < 0); if (fhi >= 0) { lo = hi; flo = fhi; } }

  if (!feasible) {
    const pick = (inc ? (Math.abs(fhi) <= Math.abs(flo) ? hi : lo) : (Math.abs(flo) <= Math.abs(fhi) ? lo : hi));
    scResult.textContent = "Target not achievable within bounds; using nearest bound.";
    const s = getSigma();
    const patch = (lever === 'retirement_age') ? { retirement_age: Math.round(pick) }
              : (lever === 'annual_expense') ? { annual_expense: pick }
              : (lever === 'annual_saving')  ? { annual_saving: pick }
              : { return_rate_after: pick, return_mean_after: pick + 0.5 * s * s };
    await commitFull(buildOverrides(pick), patch);
    return;
  }

  for (let k = 0; k < maxIter && Math.abs(hi - lo) > tolX; k++) {
    const mid = (lo + hi) / 2;
    const fmid = await f(mid);
    if (inc) { if (fmid >= 0) { hi = mid; fhi = fmid; } else { lo = mid; flo = fmid; } }
    else     { if (fmid >= 0) { lo = mid; flo = fmid; } else { hi = mid; fhi = fmid; } }
    if (Math.abs(fmid) < tolF) { lo = hi = mid; break; }
  }

  const xStar = inc ? hi : lo;

  const isMonthly = (lever === 'annual_expense' || lever === 'annual_saving');
  const isPercent = (lever === 'post_ret_return');

  let displayAge = xStar;
  if (lever === 'retirement_age') {
    const ageLo = Math.round(lo);
    const ageHi = Math.round(hi);
    const assetsLo = targetAssets + flo;
    const assetsHi = targetAssets + fhi;

    if (
      ageHi !== ageLo &&
      Number.isFinite(assetsLo) &&
      Number.isFinite(assetsHi) &&
      Math.abs(assetsHi - assetsLo) > 1e-9
    ) {
      const t = (targetAssets - assetsLo) / (assetsHi - assetsLo);
      displayAge = ageLo + Math.min(1, Math.max(0, t));
    } else {
      displayAge = Math.round(xStar);
    }
  }

  const leverName = {
    retirement_age: 'Retirement age',
    annual_expense: 'Spending (monthly)',
    annual_saving:  'Savings (monthly)',
    post_ret_return:'Post-ret return (%)'
  }[lever];

  const displayVal =
    (lever === 'retirement_age') ? displayAge
    : isMonthly ? (xStar / 12)
    : isPercent ? (xStar * 100)
    : xStar;

  const unit = isMonthly ? ' /mo' : '';
  const pretty = v =>
    (lever === 'retirement_age')
      ? (+Number(v).toFixed(1)).toString()
      : (isPercent ? ((+Number(v).toFixed(1)) + '%')
                   : '$' + Math.round(v).toLocaleString());

  scResult.textContent =
    `${leverName}: ${pretty(displayVal)}${unit} ` +
    `(meets ${scMetric.options[scMetric.selectedIndex].text} ` +
    `≥ $${(+scAssets.value).toLocaleString()} at age ${Math.round(targetAge)})`;

  const s = getSigma();
  const patch =
    (lever === 'retirement_age') ? { retirement_age: Math.round(xStar) } :
    (lever === 'annual_expense') ? { annual_expense: xStar } :
    (lever === 'annual_saving')  ? { annual_saving:  xStar } :
                                   { return_rate_after: xStar, return_mean_after: xStar + 0.5 * s * s };

  await commitFull(buildOverrides(xStar), patch);
}

scSolve.addEventListener('click', solve);
scClear.addEventListener('click', () => { window.__coach_goals = []; scResult.textContent = ''; ping(); });
document.getElementById('lw_reset').addEventListener('click', () => {
  const f = gatherForm(); setSlidersFromForm(f); hydrateStdMirrors(); updateLabelsFromSliders(); ping();
});

// 🔗 Goals -> Live What-If (ensure + Add Goal / toggle triggers ONE redraw)
(function hookGoalsToLive() {
  function attach() {
    if (window.GoalsModule?.onChange) {
      window.GoalsModule.onChange(() => { ping(); });
      return true;
    }
    return false;
  }
  if (!attach()) {
    const iv = setInterval(() => { if (attach()) clearInterval(iv); }, 200);
    setTimeout(() => clearInterval(iv), 5000);
  }
})();

console.log("Live What-If ready (300 sims; horizon from slider; At-age used only for evaluation; std-dev mirrors wired)");
window.__liveTest = { ping, collectParams };
ping(); // initial draw
})();
</script>

<!-- Tooltip init (place AFTER the Live What-If script, BEFORE </body>) -->
<script>
(() => {
  function initTooltips() {
    if (!window.bootstrap || !bootstrap.Tooltip) return false;
    document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => {
      // avoid double-initializing
      if (!bootstrap.Tooltip.getInstance(el)) {
        new bootstrap.Tooltip(el);
      }
    });
    return true;
  }
  // Run now if possible; otherwise try again on DOM ready & on window load
  if (!initTooltips()) {
    document.addEventListener('DOMContentLoaded', initTooltips);
    window.addEventListener('load', initTooltips);
  }
})();
</script>










{% if sensitivities %}
<div class="mt-4">
  <h5 class="text-center mb-3">🔍 Sensitivity Analysis</h5>

  <div class="row g-3">
    <!-- Table -->
    <div class="col-md-6">
      <div class="table-responsive">
        <table class="table table-sm table-bordered text-center">
          <thead class="table-light">
            <tr>
              <th>Parameter</th>
              <th>Elasticity<br>(%Δ Output / %Δ Input)</th>
              <th>Dollar Impact ($)</th>
            </tr>
          </thead>
          <tbody>
            {% for var, vals in sensitivities.items() %}
              <tr>
                <td>
                  {% if var == 'return_rate' %}
                    Pre-Retire Return Rate
                  {% elif var == 'return_rate_after' %}
                    Post-Retire Return Rate
                  {% elif var == 'retirement_age' %}
                    Retirement Age <span class="badge bg-secondary ms-1">separate scale</span>
                  {% else %}
                    {{ var.replace('_', ' ').title() }}
                  {% endif %}
                </td>
                <td>{{ "{:.2f}".format(vals.sensitivity_pct) }}%</td>
                <td>${{ "{:,.0f}".format(vals.dollar_impact) }}</td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    </div>

    <!-- Charts -->
    <div class="col-md-6">
      <!-- Core inputs -->
      <div class="card mb-3">
        <div class="card-header">Dollar Impact – Core Inputs</div>
        <div class="card-body">
          <div style="width:100%; height:300px;">
            <canvas id="dollarImpactCoreChart"></canvas>
          </div>
        </div>
      </div>

      <!-- Retirement Age (own scale) -->
      <div class="card">
        <div class="card-header">Retirement Age – Dollar Impact (Own Scale)</div>
        <div class="card-body">
          <div style="width:100%; height:150px;">
            <canvas id="dollarImpactRAChart"></canvas>
          </div>
          {% if sensitivities.get('retirement_age') %}
            <div class="text-muted small mt-2">
              +1% change in <em>Retirement Age</em> ⇒
              ${{ "{:,.0f}".format(sensitivities['retirement_age'].dollar_impact) }}
              (Elasticity: {{ "{:.0f}".format(sensitivities['retirement_age'].sensitivity_pct) }}%)
            </div>
          {% endif %}
        </div>
      </div>
    </div>
  </div>

  <div class="mt-3">
    <p><strong>Elasticity</strong> shows the % change in <em>Final Assets</em> from a 1% increase in each input.</p>
    <p><strong>Dollar Impact</strong> shows the absolute change in <em>Final Assets</em> for that same 1% increase.</p>
  </div>
</div>

<!-- Chart.js for sensitivity bars -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  (function(){
    // Build Core vs RA arrays from the server-side sensitivities
    const coreLabels = [];
    const coreData   = [];
    let raValue = null;

    {% for var, vals in sensitivities.items() %}
      {% if var != 'retirement_age' %}
        {% if var == 'current_assets' %}
          coreLabels.push('Current Assets');
        {% elif var == 'return_rate' %}
          coreLabels.push('Pre-Retire Return Rate');
        {% elif var == 'return_rate_after' %}
          coreLabels.push('Post-Retire Return Rate');
        {% elif var == 'annual_saving' %}
          coreLabels.push('Annual Saving');
        {% elif var == 'annual_expense' %}
          coreLabels.push('Annual Expense');
        {% elif var == 'saving_increase_rate' %}
          coreLabels.push('Saving Increase Rate');
        {% elif var == 'inflation_rate' %}
          coreLabels.push('Inflation Rate');
        {% elif var == 'income_tax_rate' %}
          coreLabels.push('Income Tax Rate');
        {% else %}
          coreLabels.push('{{ var.replace("_", " ").title() }}');
        {% endif %}
        coreData.push({{ vals.dollar_impact }});
      {% else %}
        raValue = {{ sensitivities['retirement_age'].dollar_impact }};
      {% endif %}
    {% endfor %}

    // Common tick style for readability
    const tickStyle = {
      color: '#111',
      font: { size: 12, weight: 'bold' }
    };

    // ----- Core inputs chart -----
    if (coreLabels.length) {
      const maxImpact = Math.max(...coreData.map(v => Math.abs(v))) || 1;

      new Chart(document.getElementById('dollarImpactCoreChart').getContext('2d'), {
        type: 'bar',
        data: {
          labels: coreLabels,
          datasets: [{
            label: 'Dollar Impact',
            data: coreData,
            backgroundColor: '#4e73df'
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              min: -maxImpact,
              max:  maxImpact,
              ticks: {
                ...tickStyle,
                callback: value => '$' + Number(value).toLocaleString()
              },
              title: { display: true, text: 'Dollar Impact ($)', color: '#111', font: { weight: 'bold' } }
            },
            y: { ticks: tickStyle }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: ctx => '$' + Number(ctx.parsed.x).toLocaleString()
              }
            }
          }
        }
      });
    }

    // ----- Retirement Age chart (own scale) -----
    if (raValue !== null) {
      const raAbs = Math.abs(raValue);
      const raMax = raAbs === 0 ? 1 : raAbs * 1.1; // small headroom

      new Chart(document.getElementById('dollarImpactRAChart').getContext('2d'), {
        type: 'bar',
        data: {
          labels: ['Retirement Age'],
          datasets: [{
            label: 'Dollar Impact',
            data: [raValue],
            backgroundColor: '#7e57c2'
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              min: -raMax,
              max:  raMax,
              ticks: {
                ...tickStyle,
                callback: value => '$' + Number(value).toLocaleString()
              },
              title: { display: true, text: 'Dollar Impact ($)', color: '#111', font: { weight: 'bold' } }
            },
            y: { ticks: tickStyle }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: ctx => '$' + Number(ctx.parsed.x).toLocaleString()
              }
            }
          }
        }
      });
    }
  })();
</script>
{% endif %}




<!-- ==== Compare Saved Scenarios (plain POST) ==== -->
<hr class="my-4">
<h5 class="text-center mb-3">🔄 Compare Saved Scenarios</h5>

<form id="compare-form" class="row g-3 align-items-end" method="POST" action="{{ url_for('projects.compare_retirement') }}">
  {% if csrf_token is defined %}
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
  {% endif %}

  <!-- mirror the page's current vol settings; JS will update these before submit -->
  <input type="hidden" name="return_std"     id="cmp_return_std"     value="{{ return_std }}">
  <input type="hidden" name="inflation_std"  id="cmp_inflation_std"  value="{{ inflation_std }}">

  <div class="col-md-6">
    <label for="scenario_a" class="form-label">Scenario A</label>
    <select id="scenario_a" name="scenario_a" class="form-select" required>
      <option value="">-- Select Scenario A --</option>
      {% for s in saved_scenarios %}
        <option value="{{ s.id }}">{{ s.scenario_name }}</option>
      {% endfor %}
    </select>
  </div>

  <div class="col-md-6">
    <label for="scenario_b" class="form-label">Scenario B (optional)</label>
    <select id="scenario_b" name="scenario_b" class="form-select">
      <option value="">-- (None) --</option>
      {% for s in saved_scenarios %}
        <option value="{{ s.id }}">{{ s.scenario_name }}</option>
      {% endfor %}
    </select>
  </div>

  <div class="col-12 text-center">
    <button type="submit" class="btn btn-warning px-4">Compare</button>
  </div>
</form>







<!-- ===== Compare Volatility Check (saved in DB) ===== -->
<div id="compare-vol-check" class="card" style="margin:18px 0;">
  <div class="card-body">
    <div style="font-weight:600;margin-bottom:8px;">Volatility saved on scenarios (DB)</div>
    <div class="text-muted">Select Scenario A / B above; this shows exactly what is stored on each scenario.</div>

    <div class="small" style="margin-top:8px;">
      JSON endpoint: <a id="compare-vol-json-link" target="_blank" rel="noopener">—</a>
    </div>

    <table class="table table-sm" style="margin-top:10px;">
      <thead>
        <tr>
          <th style="width:40%">Scenario</th>
          <th style="width:30%">Return σ (saved)</th>
          <th style="width:30%">Inflation σ (saved)</th>
        </tr>
      </thead>
      <tbody id="compare-vol-check-rows">
        <tr><td colspan="3" class="text-muted">Waiting for selection…</td></tr>
      </tbody>
    </table>
    <div id="compare-vol-check-raw" class="small text-muted"></div>
  </div>
</div>

<script>
(function(){
  const url = "{{ url_for('projects.compare_vol_preview_json') }}";
  const rowsEl = document.getElementById("compare-vol-check-rows");
  const rawEl  = document.getElementById("compare-vol-check-raw");
  const linkEl = document.getElementById("compare-vol-json-link");

  function pickSelect(names) {
    for (const n of names) {
      const byName = document.querySelector(`select[name="${n}"]`);
      if (byName) return byName;
      const byId = document.getElementById(n);
      if (byId && byId.tagName === "SELECT") return byId;
    }
    return null;
  }

  const selA = pickSelect(["scenario_a","scenarioA","compare_a"]);
  const selB = pickSelect(["scenario_b","scenarioB","compare_b"]);

  function getIds() {
    return {
      a: selA ? (selA.value || "") : "",
      b: selB ? (selB.value || "") : ""
    };
  }

  async function refresh() {
    try {
      if (!selA && !selB) {
        rowsEl.innerHTML = `<tr><td colspan="3" class="text-danger">Compare selectors not found on this page.</td></tr>`;
        rawEl.textContent = "";
        return;
      }
      const ids = getIds();
      const href = `${url}?a=${encodeURIComponent(ids.a)}&b=${encodeURIComponent(ids.b)}`;
      if (linkEl) { linkEl.href = href; linkEl.textContent = href; }

      const r = await fetch(href, { method: "GET", credentials: "same-origin" });
      const text = await r.text();

      let data;
      try { data = JSON.parse(text); }
      catch (e) {
        rowsEl.innerHTML = `<tr><td colspan="3" class="text-danger">
          Non-JSON response (HTTP ${r.status}). First 120 chars:<br><code>${text.substring(0,120)
            .replace(/</g,"&lt;")}</code></td></tr>`;
        rawEl.textContent = "";
        return;
      }

      function row(label, obj) {
        if (!obj) return `<tr><td>${label}</td><td>—</td><td>—</td></tr>`;
        if (obj.error) return `<tr><td>${label}</td><td colspan="2" class="text-danger">${obj.error}</td></tr>`;
        const name = (obj.scenario_name || "").replace(/</g,"&lt;");
        const rs = obj.return_std_display || "—";
        const is = obj.inflation_std_display || "—";
        return `<tr>
                  <td>${label}: <strong>${name}</strong></td>
                  <td>${rs}</td>
                  <td>${is}</td>
                </tr>`;
      }

      rowsEl.innerHTML = row("A", data.A) + row("B", data.B);
      const rawA = data.A && data.A.raw ? JSON.stringify(data.A.raw) : "{}";
      const rawB = data.B && data.B.raw ? JSON.stringify(data.B.raw) : "{}";
      rawEl.textContent = `raw A: ${rawA}   |   raw B: ${rawB}`;
    } catch (err) {
      rowsEl.innerHTML = `<tr><td colspan="3" class="text-danger">JS error: ${String(err)}</td></tr>`;
      rawEl.textContent = "";
    }
  }

  if (selA) selA.addEventListener("change", refresh);
  if (selB) selB.addEventListener("change", refresh);

  document.addEventListener("DOMContentLoaded", () => { refresh(); setTimeout(refresh, 400); });
  window.addEventListener("load", refresh);

  // manual trigger if you want to call it from console
  window.__volPreviewRefresh = refresh;
})();
</script>




<!-- Compare block -->
<style>
  /* Clamp chart heights so they don't balloon */
  #sens-core-chart, #sens-ra-chart { max-height: 320px; }
  #sens-ra-chart { max-height: 110px; }
</style>

<div id="compare-block" class="mt-5 d-none">
  <hr class="my-4">
  <h5 class="text-center mb-3" id="compare-title">🔄 Compare</h5>

  <!-- MC (Plotly) -->
  <div class="card mb-4">
    <div class="card-header">Monte Carlo Simulation</div>
    <div class="card-body">
      <p id="compare-age-spans" class="text-muted small mb-2 d-none"></p>
      <div id="mc-compare-plot" style="height:400px;"></div>
    </div>
  </div>

  <!-- Sensitivity: Core -->
  <div id="sens-core-card" class="card mb-4 d-none">
    <div class="card-header">Sensitivity – Dollar Impact (Core Inputs)</div>
    <div class="card-body">
      <canvas id="sens-core-chart" style="height:320px;"></canvas>
    </div>
  </div>

  <!-- Sensitivity: Retirement Age (own scale) -->
  <div id="sens-ra-card" class="card mb-4 d-none">
    <div class="card-header">Retirement Age – Dollar Impact (Own Scale)</div>
    <div class="card-body">
      <canvas id="sens-ra-chart" style="height:110px;"></canvas>
      <div id="sens-ra-note" class="text-muted small mt-2"></div>
    </div>
  </div>
</div>

<!-- libs -->
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
(function(){
  const form = document.getElementById('compare-form');
  if (!form) return;

  let sensChartCore = null;
  let sensChartRA   = null;

  form.addEventListener('submit', async (e) => {
    e.preventDefault();

    const fd = new FormData(form);
    const res = await fetch('{{ url_for("projects.compare_retirement") }}', {
      method: 'POST',
      body: fd,
      credentials: 'same-origin'
    });

    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if (!ct.includes('application/json')) {
      const txt = await res.text();
      alert('Compare failed (non-JSON):\n' + txt.slice(0,300));
      return;
    }

    const cd = await res.json();
    if (!res.ok) { alert(cd.error || 'Compare failed.'); return; }

    // Show “A: start–end | B: start–end” if backend provides it
    updateAgeSpans(cd.meta || null);

    renderOverlay(cd);
    renderSensitivitySplit(cd);
  });


// ---------- MC overlay (Plotly) ----------
function renderOverlay(cd){
  const labelA = (cd.labels && cd.labels.A) || 'Scenario A';
  const labelB = (cd.labels && cd.labels.B) || 'Scenario B';
  const ages  = (cd.mc.ages || []).map(Number);

  const A = {
    p10: (cd.mc.p10.A || []).map(v => v === null ? null : Number(v)),
    p50: (cd.mc.p50.A || []).map(v => v === null ? null : Number(v)),
    p90: (cd.mc.p90.A || []).map(v => v === null ? null : Number(v))
  };
  const hasB = cd.mc.p10.B && cd.mc.p50.B && cd.mc.p90.B;
  const B = hasB ? {
    p10: (cd.mc.p10.B || []).map(v => v === null ? null : Number(v)),
    p50: (cd.mc.p50.B || []).map(v => v === null ? null : Number(v)),
    p90: (cd.mc.p90.B || []).map(v => v === null ? null : Number(v))
  } : null;

  const traces = [
    { x: ages, y: A.p10, connectgaps: false, fill: 'none',
      line: { color: 'rgba(0,100,200,0.2)', width: 0 }, hoverinfo:'skip', showlegend:false },
    { x: ages, y: A.p90, connectgaps: false, fill: 'tonexty', fillcolor: 'rgba(0,100,200,0.2)',
      line: { color: 'rgba(0,100,200,0.2)', width: 0 }, hoverinfo:'skip', showlegend:false },
    { x: ages, y: A.p50, connectgaps: false, mode: 'lines+markers',
      name: `${labelA} – Median`, line: { color: 'blue' },
      hovertemplate: 'Age %{x}<br>$%{y:,.0f}<extra></extra>' }
  ];

  if (B) {
    traces.push(
      { x: ages, y: B.p10, connectgaps: false, fill: 'none',
        line: { color: 'rgba(255,159,64,0.2)', width: 0 }, hoverinfo:'skip', showlegend:false },
      { x: ages, y: B.p90, connectgaps: false, fill: 'tonexty', fillcolor: 'rgba(255,159,64,0.2)',
        line: { color: 'rgba(255,159,64,0.2)', width: 0 }, hoverinfo:'skip', showlegend:false },
      { x: ages, y: B.p50, connectgaps: false, mode: 'lines+markers',
        name: `${labelB} – Median`, line: { color: 'orange' },
        hovertemplate: 'Age %{x}<br>$%{y:,.0f}<extra></extra>' }
    );
  }

  const layout = {};
  const axisSeries = [A.p10, A.p50, A.p90].concat(B ? [B.p10, B.p50, B.p90] : []);
  ensureLayout(layout, axisSeries);

  showCompareBlock();
  showTitle(B ? `🔄 Compare: ${labelA} vs ${labelB}` : `🔄 Compare: ${labelA}`);
  Plotly.react('mc-compare-plot', traces, layout, { responsive: true });
}



  // ---------- Sensitivity (SPLIT) ----------
  function renderSensitivitySplit(cd){
    if (!cd.sens || !Array.isArray(cd.sens.vars)) {
      hideSensitivity();
      return;
    }

    const labelA = (cd.labels && cd.labels.A) || 'Scenario A';
    const labelB = (cd.labels && cd.labels.B) || null;

    const vars = cd.sens.vars.slice();
    const A    = (cd.sens.A   || []).slice();
    const B    = (cd.sens.B   || null) ? cd.sens.B.slice() : null;

    const raIdx = vars.indexOf('retirement_age');
    let raA = null, raB = null;
    if (raIdx !== -1) {
      raA = (A[raIdx] != null) ? Number(A[raIdx]) : null;
      raB = (B && B[raIdx] != null) ? Number(B[raIdx]) : null;
      vars.splice(raIdx, 1);
      A.splice(raIdx, 1);
      if (B) B.splice(raIdx, 1);
    }

    const LABELS = {
      current_assets:        'Current Assets',
      return_rate:           'Pre-Retire Return Rate',
      return_rate_after:     'Post-Retire Return Rate',
      annual_saving:         'Annual Saving',
      annual_expense:        'Annual Expense',
      saving_increase_rate:  'Saving Increase Rate',
      inflation_rate:        'Inflation Rate',
      income_tax_rate:       'Income Tax Rate',
      retirement_age:        'Retirement Age'
    };

    const coreLabels = vars.map(v => LABELS[v] ?? v.replace(/_/g, ' ').replace(/\b\w/g,c=>c.toUpperCase()));
    const coreA = A.map(Number);
    const coreB = B ? B.map(Number) : null;

    const tickStyle = { color: '#111', font: { size: 12, weight: 'bold' } };

    // Core chart
    if (coreLabels.length) {
      const maxImp = Math.max(
        ...(coreA.map(Math.abs)),
        ...(coreB ? coreB.map(Math.abs) : [0])
      ) || 1;

      const ds = [{ label: labelA, data: coreA, backgroundColor: 'rgba(54,162,235,0.55)' }];
      if (coreB) ds.push({ label: labelB, data: coreB, backgroundColor: 'rgba(255,159,64,0.55)' });

      const ctxCore = document.getElementById('sens-core-chart').getContext('2d');
      if (sensChartCore) sensChartCore.destroy();
      sensChartCore = new Chart(ctxCore, {
        type: 'bar',
        data: { labels: coreLabels, datasets: ds },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              min: -maxImp, max: maxImp,
              title: { display: true, text: 'Dollar Impact ($)', color: '#111', font: { weight: 'bold' } },
              ticks: {
                ...tickStyle,
                callback: v => '$' + Number(v).toLocaleString()
              },
              grid: { color: 'rgba(0,0,0,0.06)' }
            },
            y: { ticks: tickStyle, grid: { color: 'rgba(0,0,0,0.03)' } }
          },
          plugins: {
            legend: { position: 'bottom' },
            tooltip: {
              callbacks: {
                label: (c) => `${c.dataset.label}: $${Number(c.parsed.x).toLocaleString()}`
              }
            }
          }
        }
      });
      document.getElementById('sens-core-card').classList.remove('d-none');
    } else {
      document.getElementById('sens-core-card').classList.add('d-none');
      if (sensChartCore) { sensChartCore.destroy(); sensChartCore = null; }
    }

    // Retirement Age (own scale)
    if (raA != null || raB != null) {
      const labels = ['Retirement Age'];
      const dsRA = [{ label: labelA, data: [raA || 0], backgroundColor: 'rgba(54,162,235,0.55)' }];
      if (raB != null) dsRA.push({ label: labelB, data: [raB], backgroundColor: 'rgba(255,159,64,0.55)' });

      const ctxRA = document.getElementById('sens-ra-chart').getContext('2d');
      if (sensChartRA) sensChartRA.destroy();
      sensChartRA = new Chart(ctxRA, {
        type: 'bar',
        data: { labels, datasets: dsRA },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: { display: true, text: 'Dollar Impact ($)', color: '#111', font: { weight: 'bold' } },
              ticks: {
                ...tickStyle,
                callback: v => '$' + Number(v).toLocaleString()
              },
              grid: { color: 'rgba(0,0,0,0.06)' }
            },
            y: { ticks: tickStyle, grid: { color: 'rgba(0,0,0,0.03)' } }
          },
          plugins: {
            legend: { position: 'bottom' },
            tooltip: {
              callbacks: {
                label: (c) => `${c.dataset.label}: $${Number(c.parsed.x).toLocaleString()}`
              }
            }
          }
        }
      });

      const note = document.getElementById('sens-ra-note');
      if (raA != null) {
        note.textContent =
          `A +1% change in Retirement Age affects Final Assets by ${raA >= 0 ? '+' : ''}$${Math.abs(raA).toLocaleString()} for Scenario A`
          + (raB != null ? `; Scenario B: ${raB >= 0 ? '+' : ''}$${Math.abs(raB).toLocaleString()}.` : '.');
      } else {
        note.textContent = '';
      }

      document.getElementById('sens-ra-card').classList.remove('d-none');
    } else {
      document.getElementById('sens-ra-card').classList.add('d-none');
      if (sensChartRA) { sensChartRA.destroy(); sensChartRA = null; }
    }
  }

  // ---------- helpers ----------
function ensureLayout(layout, seriesForAxis){
  layout.margin = { t: 30 };
  layout.xaxis = { title: 'Age' };

  // Build right-side Y axis with labels in $K (thousands of dollars)
  // seriesForAxis: array of numeric arrays (e.g. [A.p10, A.p50, A.p90, B.p10, ...])
  const vals = [];
  (seriesForAxis || []).forEach(arr => {
    (arr || []).forEach(v => { if (v != null && isFinite(v)) vals.push(+v); });
  });
  const maxY = Math.max(1, ...(vals.length ? vals : [1]));       // avoid empty
  const nTicks = 6;                                              // ~5–7 ticks
  const rawStep = maxY / nTicks;

  function niceStep(x){
    const pow = Math.pow(10, Math.floor(Math.log10(x)));
    const n = x / pow;
    const mult = (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10);
    return mult * pow;
  }
  const step = niceStep(rawStep);

  const tickvals = [];
  for (let t = 0; t <= maxY + 1e-9; t += step) tickvals.push(t);

  const ticktext = tickvals.map(v => `${Math.round(v/1000).toLocaleString()}K`);

  layout.yaxis = {
    side: 'right',
    title: 'Projected Assets ($K)',
    tickvals,
    ticktext
  };

  layout.legend = { orientation: 'h', x: 0.1, y: -0.2 };
}

  function showCompareBlock(){
    document.getElementById('compare-block').classList.remove('d-none');
  }

  function showTitle(txt){
    document.getElementById('compare-title').textContent = txt;
  }

  function hideSensitivity(){
    const core = document.getElementById('sens-core-card');
    const ra   = document.getElementById('sens-ra-card');
    if (!core.classList.contains('d-none')) core.classList.add('d-none');
    if (!ra.classList.contains('d-none')) ra.classList.add('d-none');
    if (sensChartCore) { sensChartCore.destroy(); sensChartCore = null; }
    if (sensChartRA)   { sensChartRA.destroy();   sensChartRA   = null; }
  }

  function updateAgeSpans(meta){
    const el = document.getElementById('compare-age-spans');
    if (!el) return;
    if (meta && (meta.A || meta.B)) {
      const a = meta.A ? `${meta.A.label}: ${meta.A.start_age}–${meta.A.end_age}` : '';
      const b = meta.B ? `${meta.B.label}: ${meta.B.start_age}–${meta.B.end_age}` : '';
      el.textContent = b ? `${a}  |  ${b}` : a;
      el.classList.remove('d-none');
    } else {
      el.textContent = '';
      el.classList.add('d-none');
    }
  }
})();
</script>







        {% if table %}
        <div class="table-responsive mt-5">
            <h5 class="text-center mb-3">📊 Retirement Projection Table</h5>
            <table class="table table-bordered table-sm text-center align-middle">
                <thead class="table-light">
                    <tr>
                        <th>Age</th>
                        <th>Year</th>
                        <th>Retire?</th>
                        <th>Living Exp.</th>
                        <th>CPP / Extra Income</th>
                        <th>Income Tax Payment</th>
                        <th>Living Exp. – Ret.</th>
                        <th>Asset Liquidation</th>
                        <th>Savings – Before Retire</th>
                        <th>Asset</th>
                        <th>Asset – Retirement</th>
                        <th>Investment Return</th>
                        <th>Return Rate</th>
                        <th>Withdrawal Rate</th>
                    </tr>
                </thead>
                <tbody>
                {% for row in table %}
                  <tr>
                    {% for cell in row %}
                      <td>
                        {% if cell is number %}
                          {% if loop.index0 in [11, 12] %}
                            {{ "{:.1f}%".format(cell) }}
                          {% else %}
                            {{ "{:,.0f}".format(cell) }}
                          {% endif %}
                        {% else %}
                          {{ cell }}
                        {% endif %}
                      </td>
                    {% endfor %}
                  </tr>
                {% endfor %}
                </tbody>
            </table>
        </div>
        {% endif %}
 </div>

<!-- 1) Expose login state from Flask -->
<script type="text/javascript">
  const isUserLoggedIn = {{ 'true' if current_user.is_authenticated else 'false' }};
</script>

<!-- 2) Initialize Bootstrap tooltips -->
<script>
  const tooltipTriggerList = Array.from(
    document.querySelectorAll('[data-bs-toggle="tooltip"]')
  );
  tooltipTriggerList.forEach(el => new bootstrap.Tooltip(el));
</script>

<!-- 3) Collect inputs, call save endpoint, and guard by login -->
<script>
  // Gather all the form’s inputs into a JSON object
  function collectFormInputs() {
    const inputs = {};
    document.querySelectorAll(
      'form input[type="number"], form input[type="text"], form select'
    ).forEach(el => {
      inputs[el.name] = el.value;
    });
    return inputs;
  }

  // POST to your Flask /scenarios/save endpoint
  function saveScenario(scenarioName, inputsJson) {
    fetch('/scenarios/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        scenario_name: scenarioName,
        inputs_json: inputsJson
      })
    })
    .then(r => r.json())
    .then(data => {
      if (data.message) {
        alert('Scenario saved successfully!');
      } else {
        alert('Error: ' + (data.error || 'Unknown error'));
      }
    })
    .catch(err => {
      alert('Network error: ' + err);
    });
  }

  // Entry point for Save Scenario button
  function triggerSaveScenario() {
    // 1) Redirect anonymous users
    if (!isUserLoggedIn) {
      alert('You need to register or log in to save a scenario.');
      return;
    }

    // 2) Ensure they entered a name
    const name = document.getElementById('scenario_name_input').value.trim();
    if (!name) {
      alert('Please enter a scenario name before saving.');
      return;
    }

    // 3) Collect the inputs and send
    const inputsJson = collectFormInputs();
    saveScenario(name, inputsJson);
  }

  // Load + Delete helpers
  function loadSelectedScenario() {
    const select = document.getElementById('load_scenario_select');
    const scenarioId = select.value;
    if (!scenarioId) {
      alert('Please select a scenario to load.');
      return;
    }

    fetch(`/scenarios/load/${scenarioId}`)
      .then(response => {
        if (!response.ok) throw new Error('Scenario not found');
        return response.json();
      })
      .then(data => {
        const inputs = data.inputs_json;

        // Iterate all keys in inputs JSON and set form values
    Object.entries(inputs).forEach(([key, value]) => {
      const el = document.querySelector(`[name="${key}"]`);
      if (!el) return;

      if (el.tagName.toLowerCase() === 'select') {
        const vStr = String(value);
        el.value = vStr;

        // If no option matched (e.g., "2" vs "2.0"), match by numeric value
        if (el.value !== vStr) {
          const target = Number(vStr);
          if (!Number.isNaN(target)) {
            for (const opt of Array.from(el.options)) {
              if (Number(opt.value) === target) { el.value = opt.value; break; }
            }
          }
        }
      } else {
        el.value = value;
      }
    });

        // Set the dropdown selection explicitly to the loaded scenario
        select.value = data.id || data.scenario_id || scenarioId;

        alert(`Loaded scenario: ${data.scenario_name || 'Selected scenario'}\n\n⚠️  IMPORTANT: After closing this message, please click the CALCULATE button to recompute results.`);

      })
      .catch(err => alert('Failed to load scenario: ' + err.message));
  }

  function deleteSelectedScenario() {
    const select = document.getElementById('load_scenario_select');
    const scenarioId = select.value;

    if (!scenarioId) {
      alert('Please select a scenario to delete.');
      return;
    }

    if (!confirm('Are you sure you want to delete this scenario? This action cannot be undone.')) {
      return;
    }

    fetch(`/scenarios/delete/${scenarioId}`, {
      method: 'DELETE',
    })
    .then(response => {
      if (!response.ok) throw new Error('Failed to delete scenario.');
      return response.json();
    })
    .then(data => {
      alert(data.message || 'Scenario deleted successfully.');
      // Remove deleted option from select dropdown
      const optionToRemove = select.querySelector(`option[value="${scenarioId}"]`);
      if (optionToRemove) optionToRemove.remove();
      select.value = ''; // reset selection
    })
    .catch(err => alert('Error deleting scenario: ' + err.message));
  }
</script>









<!-- === COMBINED: LITE V1 + TAX-LITE (ONE SECTION) ========================== -->
<div class="card mt-5" id="litev1_card">
  <div class="card-body">

<!-- Title (restored) -->
<div class="d-flex align-items-center justify-content-between">
  <h5 class="card-title mb-0">Deterministic + Tax-lite (combined)</h5>
  <div class="d-flex align-items-center gap-2">
    <span id="litev1_status" class="small text-muted"></span>
  </div>
</div>

<!-- Guidance ABOVE the three balances -->
<div class="row mt-3">
  <div class="col-12 small text-muted">
    <strong>Allocate your current assets</strong> across these three accounts.
    The total here should match your current portfolio balance.
    <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
          title="Enter today’s balances across Taxable, RRSP, and TFSA. The three amounts should add up to your current investable assets.">
      &#9432;
    </span>
  </div>
</div>

<!-- Balances -->
<div class="row g-3 mt-1">
  <div class="col-md-3">
    <label class="form-label">Taxable ($)
      <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
            title="Non-registered accounts. Excludes home equity. This is the portion taxed annually by yields/realized gains (via Taxable Drag).">
        &#9432;
      </span>
    </label>
    <!-- This value is filled from Top inputs; we also use it as a baseline fallback -->
    <input id="litev1_taxable" type="number" class="form-control" value="1000000" min="0" step="1">
  </div>
  <div class="col-md-3">
    <label class="form-label">RRSP ($)
      <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
            title="Registered (tax-deferred). Withdrawals are taxable; RRIF minimums start at your RRIF start age.">
        &#9432;
      </span>
    </label>
    <input id="litev1_rrsp" type="number" class="form-control" value="0" min="0" step="1">
  </div>
  <div class="col-md-3">
    <label class="form-label">TFSA ($)
      <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
            title="Tax-free account. Growth and withdrawals are not taxed.">
        &#9432;
      </span>
    </label>
    <input id="litev1_tfsa" type="number" class="form-control" value="0" min="0" step="1">
  </div>
</div>

<!-- Guardrail DIRECTLY BELOW the balances -->
<div class="row mt-1">
  <div class="col-12 small">
    Total allocated: <strong id="acct_total">$0</strong>
    <span id="acct_vs" class="text-muted"></span>
  </div>
  <div class="col-12">
    <div id="acct_guard" class="small"></div>
  </div>
</div>



<!-- Pre-retirement contribution split (applies before Retirement Age) -->
<div class="row mt-2" id="precontrib_row">
  <div class="col-12 small">
    <strong>Pre-retirement contribution split</strong>: Each pre-retirement year we deposit savings in this order
    <em>TFSA → RRSP → Taxable</em>. Amounts below are annual targets; <em>Taxable</em> is auto-computed as
    <code>Monthly Savings × 12 − TFSA − RRSP</code>.
    <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
          title="The model routes new savings before retirement in this order: TFSA up to your annual room/target, then RRSP up to its target, and any remainder to Taxable.">
      &#9432;
    </span>
  </div>

  <div class="col-md-3">
    <label class="form-label">TFSA (annual $)
      <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
            title="2025 TFSA limit is $7,000. Enter the amount you plan to contribute per year (include any carry-forward room if applicable).">
        &#9432;
      </span>
    </label>
    <input id="pre_tfsa_annual" type="number" class="form-control" value="0" min="0" step="1">
  </div>

  <div class="col-md-3">
    <label class="form-label">RRSP (annual $)
      <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
            title="Lower of 18% of prior-year earned income or CRA max (2025: $32,490). Include carry-forward room you plan to use.">
        &#9432;
      </span>
    </label>
    <input id="pre_rrsp_annual" type="number" class="form-control" value="0" min="0" step="1">
  </div>

  <div class="col-md-3">
    <label class="form-label">Taxable (annual $ — auto)
      <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
            title="Automatically computed as Monthly Savings × 12 minus TFSA minus RRSP. Negative values are clipped to $0.">
        &#9432;
      </span>
    </label>
    <input id="pre_taxable_annual" type="number" class="form-control" value="0" min="0" step="1" disabled>
  </div>

  <div class="col-md-3 d-flex align-items-end">
    <div class="small text-muted" id="pre_split_hint"></div>
  </div>

  <div class="col-12 small text-muted mt-1">
    Tip: If TFSA&nbsp;+&nbsp;RRSP exceeds <em>Monthly Savings × 12</em>, we’ll use TFSA first, then RRSP, and set Taxable to $0 for that year.
  </div>
</div>

      <div class="col-12 small text-muted">
  Savings grow each pre-retirement year by your <strong>Annual Saving Increase Rate (%)</strong>
  and are then split in this order <strong>TFSA → RRSP → Taxable</strong>.
  <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
        title="Each pre-retirement year: AnnualSavings(t) = (Monthly Savings × 12) × (1 + Increase%)^(t−1). Then we allocate min(TFSA cap for year t, remaining) → min(RRSP target, remaining) → remainder to Taxable.">
    &#9432;
  </span>
</div>

<div class="col-12 small text-muted">
  TFSA cap grows automatically from <strong>$7,000</strong> in <strong>2025</strong> by <strong>≈2.1%/yr</strong> for 2026+.
  We apply that cap before RRSP and Taxable in the yearly split.
  <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
        title="TFSA cap in year t ≥ 2026 is 7,000 × 1.021^(t − 2025). (Carry-forward room not modeled.)">
    &#9432;
  </span>
</div>


    <!-- Block B: Timing & flows (rest of the row) -->
    <div class="row g-3 mt-3">
      <div class="col-md-2">
        <label class="form-label">Start Age
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Your current age — simulation begins here.">
            &#9432;
          </span>
        </label>
        <input id="litev1_start_age" type="number" class="form-control" value="52" min="0" step="1">
      </div>
      <div class="col-md-2">
        <label class="form-label">End Age
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Life expectancy / last simulated year. Charts and table stop here.">
            &#9432;
          </span>
        </label>
        <input id="litev1_end_age" type="number" class="form-control" value="84" min="0" step="1">
      </div>
      <div class="col-md-2">
        <label class="form-label">Monthly Spend ($)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="After-tax spending target in retirement (today’s dollars; inflation handled by the model).">
            &#9432;
          </span>
        </label>
        <input id="litev1_spend" type="number" class="form-control" value="6900" min="0" step="1">
      </div>
      <div class="col-md-2">
        <label class="form-label">Return Rate (post %)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Expected annual portfolio return during retirement (after fees). Taxable Drag applies only to the Taxable slice.">
            &#9432;
          </span>
        </label>
        <input id="litev1_return" type="number" class="form-control" value="8" step="0.1" min="0" max="100">
      </div>
      <div class="col-md-2">
        <label class="form-label">Monthly Savings ($)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Pre-retirement savings. Use a negative number if you expect net top-ups (e.g., property carry costs).">
            &#9432;
          </span>
        </label>
        <input id="litev1_monthly_saving" type="number" class="form-control" value="7100" min="0" step="1">
      </div>
      <div class="col-md-2">
        <label class="form-label">Income Tax Rate (%)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Flat RRSP tax used only when brackets are OFF. Ignored when brackets are ON.">
            &#9432;
          </span>
        </label>
        <input id="litev1_income_tax" type="number" class="form-control" value="12" step="0.1" min="0" max="100">
      </div>
    </div>




    <!-- OAS / RRIF (kept together; Index OAS defaults to checked) -->
    <div class="row g-3 mt-3">
      <div class="col-md-2">
        <label class="form-label">OAS Monthly ($)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Gross monthly OAS benefit before any clawback at the start age.">
            &#9432;
          </span>
        </label>
        <input id="oas_mo" type="number" class="form-control" value="0" step="1" min="0">
      </div>
      <div class="col-md-2">
        <label class="form-label">OAS Start Age
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Age OAS payments begin.">
            &#9432;
          </span>
        </label>
        <input id="oas_start_age" type="number" class="form-control" value="0" min="0">
      </div>
      <div class="col-md-3">
        <label class="form-label">OAS Clawback Threshold ($/yr)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Net income level where OAS recovery tax begins.">
            &#9432;
          </span>
        </label>
        <input id="oas_threshold" type="number" class="form-control" value="0" step="1000" min="0">
      </div>
      <div class="col-md-2">
        <label class="form-label">Clawback Rate (%)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Percentage applied to income above the threshold (e.g., 15%).">
            &#9432;
          </span>
        </label>
        <input id="oas_rate" type="number" class="form-control" value="0" step="0.1" min="0" max="100">
      </div>
      <div class="col-md-2">
        <label class="form-label">RRIF Start Age
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Age your RRSP converts to RRIF and minimum withdrawals are enforced.">
            &#9432;
          </span>
        </label>
        <input id="rrif_start_age" type="number" class="form-control" value="0" min="0">
      </div>
      <div class="col-md-1 d-flex align-items-end">
        <div class="form-check">
          <input id="oas_index" class="form-check-input" type="checkbox" checked>
          <label class="form-check-label small" for="oas_index">
            Index OAS
            <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                  title="When checked, OAS grows with inflation from the start age.">
              &#9432;
            </span>
          </label>
        </div>
      </div>
    </div>
    <div class="row g-0">
      <div class="col-12 small text-muted mt-1">
        <em>Common inputs (example):</em>
        OAS Monthly ≈ <strong>$800</strong> starting at <strong>65</strong>;
        Clawback threshold ≈ <strong>$90,000/yr</strong>;
        Clawback rate <strong>15%</strong>;
        RRIF start age <strong>72</strong>.
        Check <strong>Index OAS</strong> to grow OAS with inflation. Adjust to your year/province.
      </div>
    </div>


    <!-- Lite brackets -->
    <div class="row g-2 mt-3" id="tax_brackets_ui">
      <div class="col-auto">
        <label class="form-label">Bracket 1 up to ($)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Top of band 1 for taxable income.">
            &#9432;
          </span>
        </label>
        <input id="tb_lim1"  type="number" class="form-control form-control-sm" value="0" placeholder="57,375">
      </div>
      <div class="col-auto">
        <label class="form-label">Rate 1 (%)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Combined marginal tax rate within band 1.">
            &#9432;
          </span>
        </label>
        <input id="tb_rate1" type="number" class="form-control form-control-sm" value="0" step="0.1" placeholder="14.5">
      </div>
      <div class="col-auto">
        <label class="form-label">Bracket 2 up to ($)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Top of band 2 for taxable income.">
            &#9432;
          </span>
        </label>
        <input id="tb_lim2"  type="number" class="form-control form-control-sm" value="0" placeholder="114,750">
      </div>
      <div class="col-auto">
        <label class="form-label">Rate 2 (%)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Combined marginal tax rate within band 2.">
            &#9432;
          </span>
        </label>
        <input id="tb_rate2" type="number" class="form-control form-control-sm" value="0" step="0.1" placeholder="20.5">
      </div>
      <div class="col-auto">
        <label class="form-label">Rate 3+ (%)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Marginal tax rate applied to income above band 2.">
            &#9432;
          </span>
        </label>
        <input id="tb_rate3" type="number" class="form-control form-control-sm" value="0" step="0.1" placeholder="26–32">
      </div>

      <!-- Bracket helper / links / note -->
      <div class="col-12 small text-muted mt-1">
        Example only: ~$57,375 → ~14.5%; ~$114,750 → ~20.5%; income above that typically ~26–32% depending on province/territory.
        <a href="https://www.canada.ca/en/revenue-agency/services/tax/individuals/frequently-asked-questions-individuals/canadian-income-tax-rates-individuals-current-previous-years.html"
           target="_blank" rel="noopener">
          See simple bracket table (CRA)
        </a>.
      </div>
      <div class="col-12 small mt-1">
        <strong>Note:</strong> With <em>brackets ON</em> the flat <em>Income Tax Rate (%)</em> is ignored.
        Use <strong>Taxable Drag (%)</strong> to include ongoing tax on taxable investment income.
        RRIF-min taxes still show under <em>“Tax paid from Taxable (overlay)”</em>.
      </div>
    </div>

    <!-- Taxable Drag (side note fills right-side whitespace) -->
    <div class="row g-3 mt-4">
      <div class="col-md-3">
        <label class="form-label">Taxable Drag (%)
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Ongoing drag on Taxable growth from distributions/fees/taxes. Use the helper to estimate.">
            &#9432;
          </span>
        </label>
        <input id="litev1_taxable_drag" type="number" class="form-control" value="0" step="0.1" min="0" max="100">
      </div>
      <div class="col-md-9 d-flex align-items-center">
        <div class="small text-muted">
          Optional friction on <em>Taxable</em> growth only. Enter manually, or use the helper below and tick
          <strong>Auto-apply</strong> to fill this for you. If you want to <em>overwrite</em> the helper, simply
          <strong>uncheck Auto-apply</strong> and type your own value here.
        </div>
      </div>
    </div>

      <!-- Hint shown only when Brackets are ON and implied drag is 0% (toggled by JS) -->
    <div id="drag_hint" class="small text-primary mt-1" style="display:none;">
      Tip: Brackets are ON and your implied <em>Taxable Drag</em> is 0%.
      For apples-to-apples with flat mode, consider adding Taxable Drag (via the helper).
    </div>

    <!-- === Taxable Drag Helper (sub-table) ================================= -->
    <div class="mt-3" id="taxdrag_helper">
      <div class="d-flex align-items-center justify-content-between">
        <h6 class="mb-2">Taxable Drag Helper</h6>
        <div class="form-check">
          <input class="form-check-input" type="checkbox" id="td_auto_apply" checked>
          <label class="form-check-label small" for="td_auto_apply">
            Auto-apply implied “Taxable Drag (%)” above
          </label>
        </div>
      </div>

      <div class="table-responsive">
        <table class="table table-sm align-middle">
          <thead>
            <tr>
              <th style="min-width:200px;" title="Income type within your Taxable account (dividends, interest, realized gains).">Stream</th>
              <th title="Share of your Taxable account in this stream (sums ≤ 100%).">Allocation (% of taxable)</th>
              <th title="Annual % paid/realized on that slice (e.g., 5% dividend; for realized gains enter % you’ll realize).">Yield (% on that slice)</th>
              <th title="Effective tax rate on that income type (after credits/inclusion).">Effective Tax Rate (%)</th>
              <th title="Row’s Allocation × Yield × Effective Rate.">Contribution to Absolute Drag (%)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Eligible dividends</td>
              <td><input id="td_a_div" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td><input id="td_y_div" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td><input id="td_t_div" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td id="td_c_div" class="text-end">0.000</td>
            </tr>
            <tr>
              <td>Interest (incl. foreign withholding)</td>
              <td><input id="td_a_int" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td><input id="td_y_int" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td><input id="td_t_int" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td id="td_c_int" class="text-end">0.000</td>
            </tr>
            <tr>
              <td>Realized capital gains<br><span class="text-muted small">Use <em>effective</em> rate (after inclusion), e.g. 50%×30% = 15%.</span></td>
              <td><input id="td_a_cg" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td><input id="td_y_cg" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td><input id="td_t_cg" type="number" class="form-control form-control-sm" value="0" step="0.1" min="0" max="100"></td>
              <td id="td_c_cg" class="text-end">0.000</td>
            </tr>
          </tbody>
          <tfoot>
            <tr>
              <th colspan="4" class="text-end">Absolute Drag (Σ contributions)</th>
              <th id="td_abs" class="text-end">0.000%</th>
            </tr>
            <tr>
              <th colspan="4" class="text-end" title="Implied Taxable Drag = Absolute Drag ÷ Return Rate (post).">Implied Taxable Drag d = Absolute Drag ÷ Return Rate</th>
              <th id="td_implied" class="text-end">0.00%</th>
            </tr>
          </tfoot>
        </table>
      </div>

      <!-- Detailed explainer (restored & expanded) -->
        <div class="small text-muted">
          <strong>Allocation</strong> is the share of your Taxable balance in that stream (total ≤ 100%).
          <strong>Yield</strong> is the annual % paid/realized on that slice (e.g., 5% dividend yield;
          for <em>realized gains</em>, enter the % of that slice you expect to realize this year —
          for example, realizing $50k on a $200k growth slice = <strong>25%</strong>).
          For each row we compute <code>Allocation × Yield × Effective&nbsp;Rate</code> to get that row’s
          contribution to <em>Absolute Drag</em> (% of the taxable balance). Summing rows gives total
          Absolute Drag. We then divide Absolute Drag by your <em>Return Rate</em> to get the model’s
          <strong>Taxable Drag (%)</strong>, which is applied to <em>Taxable growth only</em>.
        </div>
      <div class="small mt-1">
        <em>Example (common inputs):</em> 60% equities @ 2% yield taxed 10% → 0.12%; &nbsp;40% bonds @ 4% yield taxed 30% → 0.48%.
        <strong>Absolute Drag = 0.60%</strong>. With an 8% return, <strong>Taxable Drag = 0.60 ÷ 8 = 7.5%</strong>.
      </div>
    </div>

    <hr class="my-3">

    <!-- Bottom controls: order + run (kept just above visuals) -->
    <div class="row g-3 align-items-end">
      <div class="col-md-6">
        <label class="form-label">Withdrawal order
          <span class="ms-1" style="cursor:help" data-bs-toggle="tooltip" data-bs-placement="top"
                title="Applied each retirement year unless RRIF minimum is explicitly enabled. Tip: the order bars are clickable to switch orders.">
            &#9432;
          </span>
        </label>
        <select id="wd_order" class="form-select">
          <option value="taxable_tfsa_rrsp">Taxable → TFSA → RRSP</option>
          <option value="tfsa_taxable_rrsp">TFSA → Taxable → RRSP</option>
          <option value="rrsp_taxable_tfsa">RRSP → Taxable → TFSA</option>
          <option value="tfsa_rrsp_taxable">TFSA → RRSP → Taxable</option>
          <option value="taxable_rrsp_tfsa">Taxable → RRSP → TFSA</option>
          <option value="rrsp_tfsa_taxable">RRSP → TFSA → Taxable</option>
        </select>
        <div class="form-text small">Applied each retirement year (unless RRIF minimum is explicitly enabled).</div>
      </div>
      <div class="col-md-6 d-flex justify-content-md-end">
        <button id="litev1_run" class="btn btn-primary btn-lg" type="button">Run plan</button>
      </div>
    </div>
  </div>
</div>
<!-- === /COMBINED ========================================================= -->




<!-- === Tax-aware visuals (beta) ========================================= -->
<div class="card mt-4" id="taxviz_card">
  <div class="card-body">
    <div class="d-flex align-items-center justify-content-between">
      <h6 class="mb-2">Tax-aware visuals (beta)</h6>
      <span class="text-muted small">Parity mode — charts never block the table</span>
    </div>

    <div class="row g-3">
      <div class="col-md-6"><canvas id="taxviz_orders" width="560" height="275"></canvas></div>
      <div class="col-md-6"><canvas id="taxviz_taxes"  width="560" height="275"></canvas></div>
    </div>

    <div class="row g-3 mt-2">
      <div class="col-12"><canvas id="taxviz_balances" width="1160" height="300"></canvas></div>
    </div>
  </div>
</div>
<!-- === /Tax-aware visuals ============================================== -->








<!-- === Optimizer (beta) + Next-$1 Analyzer (append-only) ================== -->
<div class="card mt-4" id="optimizer_card">
  <div class="card-body">
    <div class="d-flex align-items-center justify-content-between">
      <h6 class="mb-2">Optimize withdrawals (beta)</h6>
      <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="opt_toggle">
        <label class="form-check-label small" for="opt_toggle">Run optimizer after “Run plan”</label>
      </div>
    </div>

    <div class="row g-3">
      <div class="col-md-6">
        <div class="p-2 rounded border">
          <div class="small text-muted mb-1">Next-$1 Analyzer (first retirement year)</div>
          <div class="small" id="n1_rrsp">RRSP marginal on next $1: —</div>
          <div class="small" id="n1_taxable">Taxable marginal on next $1: —</div>
          <div class="small" id="n1_oas">OAS headroom / status: —</div>
          <div class="small text-muted mt-1" id="n1_hint"></div>
        </div>
      </div>
      <div class="col-md-6">
        <div class="p-2 rounded border">
          <div class="small text-muted mb-1">Optimizer result (summary)</div>
          <div class="small" id="opt_summary">—</div>
          <div class="small text-muted" id="opt_rationale"></div>
        </div>
      </div>
    </div>
  </div>
</div>






    <!-- Results table -->
    <div class="table-responsive">
      <table class="table table-sm" id="litev1_tax_table">
        <thead>
          <tr>
            <th>Age</th>
            <th>Baseline Assets (100% Taxable)</th>
            <th>From Taxable</th>
            <th>From TFSA</th>
            <th>From RRSP (Gross)</th>
            <th>RRIF Min %</th>
            <th>OAS (Gross)</th>
            <th>OAS Clawback</th>
            <th>OAS (Net)</th>
            <th>Tax on Taxable (overlay)</th>
            <th>Tax on RRSP (overlay)</th>
            <th>Taxable Drag</th>
            <th>End Taxable</th>
            <th>End TFSA</th>
            <th>End RRSP</th>
            <th>End Total</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <p class="small text-muted mb-0" id="litev1_tax_meta"></p>
  </div>
</div>

<script>
(function () {
  const $ = (id) => document.getElementById(id);
  const urlRunFull = "/lite_v1/det_from_top";
  const setStatus = (msg) => { const n=$("litev1_status"); if(n) n.textContent=msg; };

  const iFmt = (n) =>
    (n===null || n===undefined || isNaN(n)) ? "" :
    Number(n).toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0});

  const pick = (name) => document.getElementById(name) || document.querySelector(`[name="${name}"]`);
  const numVal = (el) => {
    if (!el) return undefined;
    const s = (el.value ?? "").toString().replace(/,/g,"").trim();
    if (s==="") return undefined;
    const v = Number(s);
    return Number.isFinite(v) ? v : undefined;
  };

  // --- helpers to read "top" fields if present elsewhere --------------------
  function numValAny() {
    for (const key of arguments) {
      const el = pick(key);
      const v = numVal(el);
      if (Number.isFinite(v)) return v;
    }
    return undefined;
  }
  function monthlyCPPFromTop() {
    const monthly = numValAny("cpp_monthly","cpp_support","cpp","cpp_extra_income","monthly_cpp","cpp_income_monthly");
    if (Number.isFinite(monthly)) return monthly;
    const annual = numValAny("cpp_annual","cpp_support_annual","cpp_income_annual");
    if (Number.isFinite(annual)) return annual / 12.0;
    return 0;
  }
  function cppStartFromTop(dflt) { return numValAny("cpp_from_age","cpp_start_age") ?? dflt; }
  function cppEndFromTop(dflt)   { return numValAny("cpp_to_age","cpp_end_age")   ?? dflt; }

  // Prefill from top (baseline mirrors: all taxable by default)
  function prefillFromTop() {
    const current_age    = numVal(pick("current_age"));
    const lifespan       = numVal(pick("lifespan"));
    const monthly_exp    = numVal(pick("monthly_living_expense")) ?? numVal(pick("monthly_living_expenses"));
    const pre_ret_pct    = numVal(pick("pre_retire_return_rate")) ?? numVal(pick("return_rate"));
    const monthlySavingEl= pick("monthly_saving") || pick("annual_saving");
    const monthly_saving = numVal(monthlySavingEl);
    const tax_pct        = numVal(pick("income_tax_rate"));

    if (current_age !== undefined) $("litev1_start_age").value = current_age;
    if (lifespan    !== undefined) $("litev1_end_age").value   = lifespan;
    if (monthly_exp !== undefined) $("litev1_spend").value     = Math.round(monthly_exp);
    if (pre_ret_pct !== undefined) $("litev1_return").value    = pre_ret_pct;
    if (monthly_saving !== undefined) $("litev1_monthly_saving").value = Math.round(monthly_saving);
    if (tax_pct !== undefined) $("litev1_income_tax").value = tax_pct;

    const current_assets = numVal(pick("current_assets"));
    const tTaxable = numVal(pick("taxable"));
    const tRRSP    = numVal(pick("rrsp"));
    const tTFSA    = numVal(pick("tfsa"));
    const derivedTotal = [tTaxable, tRRSP, tTFSA].reduce((s,v)=> s + (Number.isFinite(v) ? v : 0), 0);
    const totalAssets = (current_assets !== undefined) ? current_assets : (derivedTotal > 0 ? derivedTotal : undefined);
    if (totalAssets !== undefined) {
      $("litev1_taxable").value = Math.round(totalAssets);
      $("litev1_rrsp").value    = 0;
      $("litev1_tfsa").value    = 0;
    }
  }
  function wireTopAssetsLiveSync(){
    ["current_assets","taxable","rrsp","tfsa"].forEach(id=>{
      const el = pick(id);
      if (el) el.addEventListener("input", prefillFromTop);
    });
  }
  document.addEventListener("DOMContentLoaded", ()=>{ prefillFromTop(); wireTopAssetsLiveSync(); });

  // Withdrawal order --> array of keys
  function readDrawOrder() {
    const v = ($("wd_order")?.value) || "taxable_tfsa_rrsp";
    const map = {
      taxable_tfsa_rrsp: ["taxable","tfsa","rrsp"],
      tfsa_taxable_rrsp: ["tfsa","taxable","rrsp"],
      rrsp_taxable_tfsa: ["rrsp","taxable","tfsa"],
      tfsa_rrsp_taxable: ["tfsa","rrsp","taxable"],
      taxable_rrsp_tfsa: ["taxable","rrsp","tfsa"],
      rrsp_tfsa_taxable: ["rrsp","tfsa","taxable"],
    };
    return map[v] || map.taxable_tfsa_rrsp;
  }

  // ------- Taxable Drag Helper logic ----------------------------------------
  function _pctSafe(x){ return Number.isFinite(x) ? Math.max(0, x) : 0; }

  function readHelperDrag() {
    const aDiv = _pctSafe(numVal($("td_a_div"))) / 100, yDiv = _pctSafe(numVal($("td_y_div"))) / 100, tDiv = _pctSafe(numVal($("td_t_div"))) / 100;
    const aInt = _pctSafe(numVal($("td_a_int"))) / 100, yInt = _pctSafe(numVal($("td_y_int"))) / 100, tInt = _pctSafe(numVal($("td_t_int"))) / 100;
    const aCg  = _pctSafe(numVal($("td_a_cg")))  / 100, yCg  = _pctSafe(numVal($("td_y_cg")))  / 100, tCg  = _pctSafe(numVal($("td_t_cg")))  / 100;

    const cDiv = aDiv * yDiv * tDiv * 100;
    const cInt = aInt * yInt * tInt * 100;
    const cCg  = aCg  * yCg  * tCg  * 100;

    const absPct = cDiv + cInt + cCg;
    const rPct   = _pctSafe(numVal($("litev1_return")));
    const impliedPct = (rPct > 0) ? (absPct / rPct * 100) : 0;

    $("td_c_div").textContent = cDiv.toFixed(3);
    $("td_c_int").textContent = cInt.toFixed(3);
    $("td_c_cg").textContent  = cCg.toFixed(3);
    $("td_abs").textContent   = absPct.toFixed(3) + "%";
    $("td_implied").textContent = impliedPct.toFixed(2) + "%";

    if ($("td_auto_apply")?.checked) {
      $("litev1_taxable_drag").value = impliedPct.toFixed(2);
    }
    return { absPct, impliedPct };
  }

  ["td_a_div","td_y_div","td_t_div","td_a_int","td_y_int","td_t_int","td_a_cg","td_y_cg","td_t_cg","litev1_return","td_auto_apply"]
    .forEach(id => $(id)?.addEventListener("input", ()=>{ readHelperDrag(); runAll(); }));

  // --- OAS / RRIF helpers ----------------------------------------------------
  function rrifMinPct(age){
    // CRA schedule; below 71 use 1/(90-age); 95+ fixed at 20%
    const t = {
      71: 0.0528, 72: 0.0540, 73: 0.0553, 74: 0.0567, 75: 0.0582, 76: 0.0598, 77: 0.0617, 78: 0.0636, 79: 0.0658,
      80: 0.0682, 81: 0.0708, 82: 0.0738, 83: 0.0771, 84: 0.0808, 85: 0.0851, 86: 0.0899, 87: 0.0955, 88: 0.1021,
      89: 0.1099, 90: 0.1192, 91: 0.1306, 92: 0.1449, 93: 0.1634, 94: 0.1879
    };
    if (age >= 95) return 0.20;
    if (age >= 71) return t[age] || 0;
    return 1 / (90 - age); // CRA formula for <71
  }

  function oasGrossAtAge(cfg, age){
    if (!cfg.oas_monthly || !cfg.oas_start_age || age < cfg.oas_start_age) return 0;
    const years = Math.max(0, age - cfg.oas_start_age);
    const factor = cfg.oas_index ? Math.pow(1 + cfg.inflation_rate, years) : 1;
    return cfg.oas_monthly * 12 * factor;
  }



// ---------- Lite bracket helpers (REQUIRED) ----------
function readBracketsFromUI() {
  const getN = id => {
    const el = document.getElementById(id);
    if (!el) return NaN;
    const v = Number((el.value ?? "").toString().replace(/,/g, "").trim());
    return Number.isFinite(v) ? v : NaN;
  };

  const lim1 = getN("tb_lim1");
  const lim2 = getN("tb_lim2");
  const r1   = getN("tb_rate1");
  const r2   = getN("tb_rate2");
  const r3   = getN("tb_rate3");

  // If ALL five fields are missing/zero/blank -> disable bracket mode
  const allBlankOrZero = [lim1, lim2, r1, r2, r3].every(v => !Number.isFinite(v) || v === 0);
  if (allBlankOrZero) return null;   // <- brackets OFF (use flat overlay engine)

  // Otherwise sanitize and enable brackets
  const L1 = Number.isFinite(lim1) && lim1 > 0 ? lim1 : 50000;
  const L2 = Math.max(L1, (Number.isFinite(lim2) && lim2 > 0 ? lim2 : 100000));

  const rate1 = (Number.isFinite(r1) && r1 >= 0 ? r1 : 10) / 100;
  const rate2 = (Number.isFinite(r2) && r2 >= 0 ? r2 : 20) / 100;
  const rate3 = (Number.isFinite(r3) && r3 >= 0 ? r3 : 30) / 100;

  return {
    enabled: true,
    bands: [
      { limit: L1,       rate: rate1 },
      { limit: L2,       rate: rate2 },
      { limit: Infinity, rate: rate3 }
    ]
  };
}

// Total tax for a given income with progressive brackets
function taxFromBrackets(income, bracketsObj) {
  const y  = Math.max(0, Number(income) || 0);
  const br = (bracketsObj?.bands?.length ? bracketsObj.bands : [
    { limit: 50000,  rate: 0.10 },
    { limit: 100000, rate: 0.20 },
    { limit: Infinity, rate: 0.30 }
  ]);

  let tax = 0, prev = 0;
  for (const b of br) {
    const upto = Math.min(y, b.limit);
    if (upto > prev) tax += (upto - prev) * (b.rate || 0);
    if (y <= b.limit) return tax;
    prev = b.limit;
  }
  const lastRate = (br[br.length - 1] || {}).rate || 0;
  return tax + Math.max(0, y - prev) * lastRate;
}

// Incremental tax for adding `delta` income on top of `base`
function incrementalTax(delta, base, bracketsObj) {
  const b  = Math.max(0, Number(base)  || 0);
  const d  = Math.max(0, Number(delta) || 0);
  const t0 = taxFromBrackets(b, bracketsObj);
  const t1 = taxFromBrackets(b + d, bracketsObj);
  return Math.max(0, t1 - t0);
}



// --- UI helper for pre-retire savings allocatoin: keep "Taxable (annual — auto)" in sync ----------------------
function updatePreSplitUI(){
  const fmt = v => "$" + Math.round(v).toLocaleString();
  const moSav = Number(document.getElementById("litev1_monthly_saving")?.value || 0);
  const tfsaA = Number(document.getElementById("pre_tfsa_annual")?.value || 0);
  const rrspA = Number(document.getElementById("pre_rrsp_annual")?.value || 0);

  const annual = Math.max(0, moSav * 12);
  const taxableA = Math.max(0, annual - tfsaA - rrspA);

  const out = document.getElementById("pre_taxable_annual");
  if (out) out.value = Math.round(taxableA);

  const hint = document.getElementById("pre_split_hint");
  if (hint) hint.textContent =
    `Computed as ${fmt(moSav)} × 12 − ${fmt(tfsaA)} − ${fmt(rrspA)} = ${fmt(taxableA)}`;
}

// keep it live
["litev1_monthly_saving","pre_tfsa_annual","pre_rrsp_annual"]
  .forEach(id => document.getElementById(id)?.addEventListener("input", () => { updatePreSplitUI(); runAll(); }));

document.addEventListener("DOMContentLoaded", updatePreSplitUI);




// Build config from UI/top
function buildCfg() {
  const current_age    = Number($("litev1_start_age").value);
  const end_age        = Number($("litev1_end_age").value);
  const taxable0       = Number($("litev1_taxable").value);
  const rrsp0          = Number($("litev1_rrsp").value);
  const tfsa0          = Number($("litev1_tfsa").value);

  const monthly_saving = Number($("litev1_monthly_saving").value);

  // NEW: read annual TFSA/RRSP targets used for the pre-retirement split
  const tfsa_annual = Number($("pre_tfsa_annual")?.value) || 0;  // e.g., 7000
  const rrsp_annual = Number($("pre_rrsp_annual")?.value) || 0;  // e.g., 30000

  const monthly_exp    = Number($("litev1_spend").value);
  const pre_ret_pct    = Number($("litev1_return").value);
  const tax_pct        = Number($("litev1_income_tax").value);

  const post_ret_pct   = numValAny("post_retire_return_rate","return_rate_after") ?? pre_ret_pct;
  const infl_pct       = numValAny("inflation_rate") ?? 2;
  const retirement_age = numValAny("retirement_age") ?? current_age;

  const cpp_mo         = monthlyCPPFromTop();
  const cpp_from       = cppStartFromTop(retirement_age);
  const cpp_to         = cppEndFromTop(end_age);

  const helper = readHelperDrag();
  const manual_drag_pct = numVal($("litev1_taxable_drag"));
  const effective_drag_pct = Number.isFinite(manual_drag_pct) ? manual_drag_pct : (helper?.impliedPct ?? 0);

  const saving_inc_pct = numValAny("saving_increase_rate") ?? 0;

  const liqs = [];
  for (let i = 1; i <= 3; i++) {
    const amt = numVal(pick(`asset_liquidation_${i}`));
    const age = numVal(pick(`asset_liquidation_age_${i}`));
    if (amt !== undefined && amt !== 0 && age !== undefined && age > 0) {
      liqs.push({ amount: amt, age: age });
    }
  }

  // Calendar anchor for pre-retirement years (falls back to current year)
  const start_year = numValAny("start_year","current_year","base_year") ?? (new Date()).getFullYear();

  // OAS/RRIF (all default to 0/off)
  const cfg = {
    current_age,
    retirement_age,
    life_expectancy: end_age,

    start_year,                      // NEW: used to map ages → calendar year
    tfsa_cagr_after_2025: 0.021,     // NEW: grow TFSA cap from 2026 onward @ 2.1%

    taxable0, rrsp0, tfsa0,

    annual_saving: (monthly_saving || 0) * 12,
    saving_increase_rate: (saving_inc_pct || 0) / 100,

    // NEW: contribution targets (caps) for the pre-retirement splitter
    pre_tfsa_annual: tfsa_annual,    // treated as the 2025 anchor (e.g., 7000)
    pre_rrsp_annual: rrsp_annual,

    annual_expense: (monthly_exp || 0) * 12,
    return_rate: (pre_ret_pct || 0) / 100,
    return_rate_after: (post_ret_pct || 0) / 100,
    inflation_rate: (infl_pct || 0) / 100,

    income_tax_rate: (tax_pct || 0) / 100,   // still used for allocation math only
    tax_brackets: readBracketsFromUI(),

    cpp_monthly: cpp_mo || 0,
    cpp_start_age: cpp_from || retirement_age,
    cpp_end_age: cpp_to || end_age,

    taxable_drag: (effective_drag_pct || 0) / 100,

    // new
    oas_monthly: Number($("oas_mo").value) || 0,
    oas_start_age: Number($("oas_start_age").value) || 0,
    oas_threshold: Number($("oas_threshold").value) || 0,
    oas_clawback_rate: (Number($("oas_rate").value) || 0) / 100,
    oas_index: !!$("oas_index")?.checked,

    rrif_start_age: Number($("rrif_start_age").value) || 0,

    asset_liquidations: liqs
  };
  return cfg;
}

// Helpers
const within = (x, a, b) => (x >= a && x <= b);
const r0 = (x) => Math.round(x||0);

function livingExpenseAtAge(cfg, age){
  const n = Math.max(0, age - cfg.current_age);
  return cfg.annual_expense * Math.pow(1 + cfg.inflation_rate, n);
}
function cppAtAge(cfg, age){
  if (!within(age, cfg.cpp_start_age, cfg.cpp_end_age)) return 0;
  const n = Math.max(0, age - cfg.cpp_start_age);
  return (cfg.cpp_monthly || 0) * 12 * Math.pow(1 + cfg.inflation_rate, n);
}
function liqMap(asset_liquidations){
  const m = {};
  (asset_liquidations || []).forEach(l=>{
    const a = Number(l.age)||0, amt = Number(l.amount)||0;
    m[a] = (m[a]||0)+amt;
  });
  return m;
}

// NEW: TFSA cap for a given calendar year
// - Up to and including 2025 -> use the user’s TFSA annual input (e.g., 7000)
// - 2026 and later            -> grow that anchor by CAGR 2.1% per year
function tfsaCapForYear(year, cfg){
  const base = Math.max(0, Number(cfg.pre_tfsa_annual) || 0);  // 2025 anchor
  if (year <= 2025) return base;
  const yrs = Math.max(0, Math.floor(year - 2025));
  const rate = Math.max(0, Number(cfg.tfsa_cagr_after_2025) || 0.021);
  return Math.round(base * Math.pow(1 + rate, yrs));
}

// Allocate by order (net need only; no overlay inside)
function allocateByOrder(netNeed, balances, order, rrspFlat) {
  let need = Math.max(0, netNeed);

  let t = balances.taxable;
  let f = balances.tfsa;
  let r = balances.rrsp;

  let fromTax = 0, fromTFSA = 0, fromRRSPGross = 0, taxRRSP = 0;

  for (const src of order) {
    if (need <= 0) break;

    if (src === "tfsa") {
      const draw = Math.min(need, f);
      fromTFSA += draw; f -= draw; need -= draw;
    } else if (src === "taxable") {
      const draw = Math.min(need, t);
      fromTax   += draw; t -= draw; need -= draw;
    } else if (src === "rrsp") {
      const netPossible = r * (1 - rrspFlat);
      const netTake     = Math.min(need, Math.max(0, netPossible));
      const gross       = netTake > 0 ? netTake / (1 - rrspFlat) : 0;
      const tax         = gross * rrspFlat;
      fromRRSPGross    += gross;
      taxRRSP          += tax;
      r                -= gross;
      need             -= netTake;
    }
  }

  // ✅ SAFETY: if any need remains and we still have Taxable, take it from Taxable.
  if (need > 0 && t > 0) {
    const draw = Math.min(need, t);
    fromTax += draw; t -= draw; need -= draw;
  }

  return {
    draws: { fromTax, fromTFSA, fromRRSPGross },
    taxes: { taxRRSP },
    shortfall: Math.max(0, need),
    endBalancesBeforeGrowth: { taxable: t, tfsa: f, rrsp: r }
  };
}

// Pre-retirement (grow, then deposit savings & liquidations)
// Taxable grows with drag; RRSP/TFSA grow normally.
// ✅ Each year we first grow the *total* savings by Top “Annual Saving Increase Rate (%)”,
// then route that year’s savings TFSA → RRSP → Taxable with the TFSA cap rule above.
function prerollToRetirement(cfg) {
  let { current_age, retirement_age, return_rate, annual_saving, saving_increase_rate,
        taxable0, rrsp0, tfsa0, asset_liquidations } = cfg;

  let age = current_age;
  let rows = [];
  let taxable = taxable0, rrsp = rrsp0, tfsa = tfsa0;
  let save = annual_saving;

  const lm = liqMap(asset_liquidations);
  const d  = Math.max(0, Math.min(1, cfg.taxable_drag || 0));
  const gN = 1 + return_rate;               // normal growth
  const gT = 1 + return_rate * (1 - d);     // dragged growth for Taxable

  while (age < retirement_age) {
    const t0 = taxable;

    // grow balances to start of year
    taxable = t0 * gT;
    rrsp    *= gN;
    tfsa    *= gN;

    // ---- deposits this year ----
    // 1) Determine calendar year for the current pre-retirement age
    const year = (cfg.start_year || (new Date()).getFullYear()) + (age - cfg.current_age);

    // 2) Compute TFSA cap for THIS year (anchor at input for ≤2025; CAGR 2.1% from 2026+)
    const tfsaCap = tfsaCapForYear(year, cfg);

    // 3) RRSP cap uses user-provided annual target (no auto growth)
    const rrspCap = Math.max(0, cfg.pre_rrsp_annual || 0);

    // 4) Route THIS YEAR's savings: TFSA → RRSP → leftover → Taxable
    const toTFSA    = Math.min(save, tfsaCap);
    const afterTFSA = Math.max(0, save - toTFSA);
    const toRRSP    = Math.min(afterTFSA, rrspCap);
    const toTaxable = Math.max(0, afterTFSA - toRRSP);

    tfsa    += toTFSA;
    rrsp    += toRRSP;
    taxable += toTaxable;

    // One-off asset liquidation this year
    if (lm[age]) taxable += lm[age];

    const endTotal = taxable + rrsp + tfsa;
    const dragAmt  = (d > 0) ? (t0 * return_rate * d) : 0;

    rows.push({
      Age: age,
      From_Taxable: 0, From_TFSA: 0, From_RRSP_Gross: 0,
      RRIF_Min_Pct: 0, OAS_Gross: 0, OAS_Clawback: 0, OAS_Net: 0,
      Tax_On_Taxable: 0, Tax_On_RRSP: 0,
      Taxable_Drag: Math.round(dragAmt),
      End_Taxable: Math.round(taxable),
      End_TFSA: Math.round(tfsa),
      End_RRSP: Math.round(rrsp),
      End_Total: Math.round(endTotal)
    });

    // 5) Grow next year's savings by the Top “Annual Saving Increase Rate (%)”
    save *= (1 + (saving_increase_rate || 0));

    age += 1;
  }
  return { rows, taxable, rrsp, tfsa };
}




// Retirement: allocate base need; OAS/RRIF gated;
// When brackets OFF -> original flat overlay on taxable (drag==0).
function runTaxYearByYearLocal(cfg, balances, baselineMap) {
  const endAge   = cfg.life_expectancy;
  const startRet = cfg.retirement_age;
  const lm       = liqMap(cfg.asset_liquidations);
  const order    = readDrawOrder();
  const flatRate = cfg.income_tax_rate || 0;

  const bracketsEnabled = !!(cfg.tax_brackets && cfg.tax_brackets.enabled);
  const bracketsObj     = cfg.tax_brackets; // may be null

  let rows = [];

  for (let age = startRet; age <= endAge; age++) {
    const expense = livingExpenseAtAge(cfg, age);
    const cpp     = cppAtAge(cfg, age);
    const oasGross= oasGrossAtAge(cfg, age);
    const netNeedInitial = Math.max(0, expense - cpp - oasGross); // assume no clawback first pass

    // 1) Allocate net need per order (first pass, using OAS gross)
    let pass = allocateByOrder(
      netNeedInitial,
      { taxable: balances.taxable, tfsa: balances.tfsa, rrsp: balances.rrsp },
      order,
      flatRate     // used only inside gross/net split for RRSP in allocator
    );

    // 2) OAS clawback (same as before)
    let incomeForClawback = pass.draws.fromRRSPGross + pass.draws.fromTax + oasGross + cpp;
    let oasClawback = 0, oasNet = oasGross;
    if (cfg.oas_monthly > 0 && cfg.oas_start_age > 0 && age >= cfg.oas_start_age &&
        cfg.oas_threshold > 0 && cfg.oas_clawback_rate > 0) {
      oasClawback = Math.max(0, incomeForClawback - cfg.oas_threshold) * cfg.oas_clawback_rate;
      oasClawback = Math.min(oasClawback, oasGross);
      oasNet      = Math.max(0, oasGross - oasClawback);
    }

    if (oasClawback > 0) {
      const topUp = allocateByOrder(
        oasClawback,
        pass.endBalancesBeforeGrowth,
        order,
        flatRate
      );
      pass.draws.fromTax       += topUp.draws.fromTax;
      pass.draws.fromTFSA      += topUp.draws.fromTFSA;
      pass.draws.fromRRSPGross += topUp.draws.fromRRSPGross;
      pass.taxes.taxRRSP       += topUp.taxes.taxRRSP; // only meaningful in flat mode
      pass.endBalancesBeforeGrowth = topUp.endBalancesBeforeGrowth;
    }

    // 3) RRIF minimum (applies in both modes, funding differences handled below)
    let rrifMinPctApplied = 0;
    if (cfg.rrif_start_age > 0 && age >= cfg.rrif_start_age) {
      rrifMinPctApplied = rrifMinPct(age);
      const mustGross   = pass.endBalancesBeforeGrowth.rrsp * rrifMinPctApplied;
      if (pass.draws.fromRRSPGross < mustGross) {
        const extraGross = mustGross - pass.draws.fromRRSPGross;

        if (bracketsEnabled) {
          // Bracket mode: compute tax only on the extra min; net goes to Taxable
          const baseIncome   = (cpp || 0) + (oasGross || 0) + (pass.draws.fromRRSPGross || 0);
          const taxBefore    = taxFromBrackets(baseIncome, bracketsObj);
          const taxAfter     = taxFromBrackets(baseIncome + extraGross, bracketsObj);
          const extraTax     = Math.max(0, taxAfter - taxBefore);
          const extraNet     = extraGross - extraTax;
          pass.endBalancesBeforeGrowth.taxable += extraNet;
          pass.endBalancesBeforeGrowth.rrsp    -= extraGross;

          // store in a temp we’ll overlay from taxable (see step 5) if drag==0
          pass.__rrifMinTax = (pass.__rrifMinTax || 0) + extraTax;
        } else {
          // Flat mode: same math but tax is flat
          const extraTax = extraGross * flatRate;
          const extraNet = extraGross - extraTax;
          pass.draws.fromRRSPGross += extraGross;
          pass.taxes.taxRRSP       += extraTax;
          pass.endBalancesBeforeGrowth.taxable += extraNet;
          pass.endBalancesBeforeGrowth.rrsp    -= extraGross;
        }
      }
    }

    // 4) Decide taxes/overlay based on mode
    const d = Math.max(0, Math.min(1, cfg.taxable_drag || 0));
    let taxOnRRSP = 0;
    let overlayTaxable = 0;

    if (bracketsEnabled) {
      // Tax on RRSP used for spending (not funded from assets)
      const baseIncome     = (cpp || 0) + (oasGross || 0);
      const rrspGrossSpend = Math.max(0, pass.draws.fromRRSPGross || 0);
      taxOnRRSP            = incrementalTax(rrspGrossSpend, baseIncome, bracketsObj);

      // Overlay only the RRIF-min tax from step 3 if drag==0
      overlayTaxable       = (d === 0) ? (pass.__rrifMinTax || 0) : 0;
    } else {
      // Original flat overlay engine (what your bar uses)
      taxOnRRSP = pass.taxes.taxRRSP || 0;
      const useOverlay = (d === 0) && (flatRate > 0);
      const grossUp    = useOverlay ? (flatRate / (1 - flatRate)) : 0;
      overlayTaxable   = useOverlay ? (pass.draws.fromTax * grossUp) : 0;
    }

    // 5) Pay overlay from taxable pre-growth, then apply one-off liquidations
    let t = pass.endBalancesBeforeGrowth.taxable;
    let f = pass.endBalancesBeforeGrowth.tfsa;
    let r = pass.endBalancesBeforeGrowth.rrsp;

    t -= Math.min(overlayTaxable, Math.max(0, t));
    if (lm[age]) t += lm[age];

    // 6) Grow (drag only on taxable)
    const gN = 1 + cfg.return_rate_after;
    const gT = 1 + cfg.return_rate_after * (1 - d);
    const t0 = t;
    const dragAmt = (d > 0) ? (t0 * cfg.return_rate_after * d) : 0;

    t = t0 * gT;
    f *= gN;
    r *= gN;

    const endTotal = t + f + r;

    rows.push({
      Age: age,
      From_Taxable: Math.round(pass.draws.fromTax + overlayTaxable),
      From_TFSA:    Math.round(pass.draws.fromTFSA),
      From_RRSP_Gross: Math.round(pass.draws.fromRRSPGross),
      RRIF_Min_Pct: (rrifMinPctApplied * 100).toFixed(2) + "%",

      OAS_Gross:    Math.round(oasGross),
      OAS_Clawback: Math.round(oasClawback),
      OAS_Net:      Math.round(oasNet),

      Tax_On_Taxable: Math.round(overlayTaxable),
      Tax_On_RRSP:    Math.round(taxOnRRSP),

      Taxable_Drag:   Math.round(dragAmt),
      End_Taxable:    Math.round(t),
      End_TFSA:       Math.round(f),
      End_RRSP:       Math.round(r),
      End_Total:      Math.round(endTotal)
    });

    balances = { taxable: t, tfsa: f, rrsp: r };
  }

  // earliest depletion (meta)
  let earliest = null;
  for (const r of rows) {
    if (Number(r.End_Total) <= 0) { earliest = Number(r.Age); break; }
  }

  return {
    rows,
    flat_tax_rate: flatRate,
    annual_spend: Math.round(Math.max(0, livingExpenseAtAge(cfg, cfg.retirement_age) - cppAtAge(cfg, cfg.retirement_age))),
    earliest_depletion_age: earliest
  };
}





  // Baseline (100% taxable) via backend
  async function runBaselineMap(cfg) {
    const res = await fetch(urlRunFull, {
      method:"POST", credentials:"same-origin",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify({
        current_age: cfg.current_age,
        retirement_age: cfg.retirement_age,
        life_expectancy: cfg.life_expectancy,
        current_assets: cfg.taxable0 + cfg.rrsp0 + cfg.tfsa0,
        annual_saving: cfg.annual_saving,
        saving_increase_rate: cfg.saving_increase_rate,
        return_rate: cfg.return_rate,
        return_rate_after: cfg.return_rate_after,
        annual_expense: cfg.annual_expense,
        cpp_monthly: cfg.cpp_monthly,
        cpp_start_age: cfg.cpp_start_age,
        cpp_end_age: cfg.cpp_end_age,
        asset_liquidations: cfg.asset_liquidations,
        inflation_rate: cfg.inflation_rate,
        income_tax_rate: cfg.income_tax_rate
      })
    });
    const out = await res.json();
    setStatus(`FULL ${res.status}`);
    const det = out.det || {};
    const ages = det.ages || det.years || [];
    const assets = det.assets || [];
    const map = {};
    for (let i=0;i<ages.length;i++) map[ages[i]] = assets[i];
    return map;
  }

  // Render
  function renderTable(rows, baselineMap, meta){
    const tb=$("litev1_tax_table").querySelector("tbody"); tb.innerHTML="";
    (rows||[]).forEach(r=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${r.Age}</td>
        <td>${iFmt(baselineMap[r.Age])}</td>
        <td>${iFmt(r.From_Taxable||0)}</td>
        <td>${iFmt(r.From_TFSA||0)}</td>
        <td>${iFmt(r.From_RRSP_Gross||0)}</td>
        <td>${r.RRIF_Min_Pct||"0.00%"}</td>
        <td>${iFmt(r.OAS_Gross||0)}</td>
        <td>${iFmt(r.OAS_Clawback||0)}</td>
        <td>${iFmt(r.OAS_Net||0)}</td>
        <td>${iFmt(r.Tax_On_Taxable||0)}</td>
        <td>${iFmt(r.Tax_On_RRSP||0)}</td>
        <td>${iFmt(r.Taxable_Drag||0)}</td>
        <td>${iFmt(r.End_Taxable||0)}</td>
        <td>${iFmt(r.End_TFSA||0)}</td>
        <td>${iFmt(r.End_RRSP||0)}</td>
        <td>${iFmt(r.End_Total||0)}</td>`;
      tb.appendChild(tr);
    });
    const orderText = readDrawOrder().join(" → ").toUpperCase();
    $("litev1_tax_meta").textContent =
      `Flat tax = ${(meta.flat_tax*100).toFixed(1)}% | ` +
      `Required withdrawal (first retirement year, net before tax, excl. OAS) = ${iFmt(meta.annual_spend)} | ` +
      `Earliest depletion age = ${meta.earliest_depletion_age ?? "—"} | ` +
      `Rows: ${rows?.length ?? 0} | Order: ${orderText}`;
  }

  // Run end-to-end
  async function runAll(){
    try{
      const cfg = buildCfg();

      const baselineMap = await runBaselineMap(cfg);
      const pre = prerollToRetirement(cfg);
      const tax = runTaxYearByYearLocal(cfg, { taxable: pre.taxable, rrsp: pre.rrsp, tfsa: pre.tfsa }, baselineMap);

      const mergedRows = [...pre.rows, ...tax.rows];
      renderTable(mergedRows, baselineMap, {
        flat_tax: tax.flat_tax_rate,
        annual_spend: tax.annual_spend,
        earliest_depletion_age: tax.earliest_depletion_age
      });


// >>> add this line <<<
if (window.renderTaxCharts) window.renderTaxCharts(mergedRows, cfg);


      setStatus("OK");
    }catch(e){
      console.error(e);
      setStatus("Run error");
    }
  }

  $("litev1_run").addEventListener("click", runAll);

  // Live re-run when inputs change
  [
    "litev1_start_age","litev1_end_age","litev1_taxable","litev1_rrsp","litev1_tfsa",
    "litev1_spend","litev1_return","litev1_monthly_saving","litev1_income_tax","wd_order",
    "litev1_taxable_drag",
    "oas_mo","oas_start_age","oas_threshold","oas_rate","rrif_start_age","oas_index",
    "tb_lim1","tb_lim2","tb_rate1","tb_rate2","tb_rate3",
    // NEW:
    "pre_tfsa_annual","pre_rrsp_annual"
  ].forEach(id => $(id)?.addEventListener("input", runAll));
  $("wd_order")?.addEventListener("change", runAll);

  // Initial helper compute
  readHelperDrag();
})();
</script>
<!-- === END COMBINED ======================================================== -->








<!-- 2) Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- 3) Charts code (exposes window.renderTaxCharts) -->
<script>
(function () {
  if (window.__taxChartsLoaded) return;
  window.__taxChartsLoaded = true;

  // ---------- utils ----------
  const num   = n => (typeof n === "number" && isFinite(n)) ? n : 0;
  const kFmt  = v => {
    const s = v < 0 ? "-" : "";
    const a = Math.abs(v);
    return s + (a/1000).toLocaleString(undefined,{maximumFractionDigits:0}) + "K";
  };
  const mFmt0  = v => "$" + (v/1e6).toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}) + "M";
  const intFmt = v => "$" + Math.round(v).toLocaleString();

  // UI order maps
  const ORDER_MAP = {
    "taxable_tfsa_rrsp": ["taxable","tfsa","rrsp"],
    "tfsa_taxable_rrsp": ["tfsa","taxable","rrsp"],
    "rrsp_taxable_tfsa": ["rrsp","taxable","tfsa"],
    "tfsa_rrsp_taxable": ["tfsa","rrsp","taxable"],
    "taxable_rrsp_tfsa": ["taxable","rrsp","tfsa"],
    "rrsp_tfsa_taxable": ["rrsp","tfsa","taxable"]
  };
  const ORDER_LABEL = {
    "taxable_tfsa_rrsp": "Taxable → TFSA → RRSP",
    "tfsa_taxable_rrsp": "TFSA → Taxable → RRSP",
    "rrsp_taxable_tfsa": "RRSP → Taxable → TFSA",
    "tfsa_rrsp_taxable": "TFSA → RRSP → Taxable",
    "taxable_rrsp_tfsa": "Taxable → RRSP → TFSA",
    "rrsp_tfsa_taxable": "RRSP → TFSA → Taxable"
  };

  // ---------- helpers (same as engine) ----------
  const within = (x,a,b)=> x>=a && x<=b;

  function rrifMinPct(age){
    const t = {71:0.0528,72:0.0540,73:0.0553,74:0.0567,75:0.0582,76:0.0598,77:0.0617,78:0.0636,79:0.0658,
               80:0.0682,81:0.0708,82:0.0738,83:0.0771,84:0.0808,85:0.0851,86:0.0899,87:0.0955,88:0.1021,
               89:0.1099,90:0.1192,91:0.1306,92:0.1449,93:0.1634,94:0.1879};
    if (age>=95) return 0.20;
    if (age>=71) return t[age]||0;
    return 1/(90-age);
  }
  function oasGrossAtAge(cfg, age){
    if (!cfg.oas_monthly || !cfg.oas_start_age || age < cfg.oas_start_age) return 0;
    const yrs = Math.max(0, age - cfg.oas_start_age);
    const f = cfg.oas_index ? Math.pow(1 + cfg.inflation_rate, yrs) : 1;
    return cfg.oas_monthly * 12 * f;
  }
  function livingExpenseAtAge(cfg, age){
    const n = Math.max(0, age - cfg.current_age);
    return cfg.annual_expense * Math.pow(1 + cfg.inflation_rate, n);
  }
  function cppAtAge(cfg, age){
    if (!within(age, cfg.cpp_start_age, cfg.cpp_end_age)) return 0;
    const n = Math.max(0, age - cfg.cpp_start_age);
    return (cfg.cpp_monthly || 0) * 12 * Math.pow(1 + cfg.inflation_rate, n);
  }
  function liqMap(liqs){
    const m={}; (liqs||[]).forEach(l=>{
      const a=Number(l.age)||0, amt=Number(l.amount)||0;
      m[a]=(m[a]||0)+amt;
    }); return m;
  }

  // Brackets use the same shape as UI: {enabled, bands:[{limit,rate},...]}
  function taxFromBrackets(income, bracketsObj) {
    const y  = Math.max(0, Number(income) || 0);
    const br = (bracketsObj?.bands?.length)
      ? bracketsObj.bands
      : [{limit:Infinity, rate:0}];
    let tax = 0, prev = 0;
    for (const b of br) {
      const upto = Math.min(y, b.limit);
      if (upto > prev) tax += (upto - prev) * (b.rate || 0);
      if (y <= b.limit) return tax;
      prev = b.limit;
    }
    const lastRate = (br[br.length-1]||{}).rate || 0;
    return tax + Math.max(0, y - prev) * lastRate;
  }
  function incrementalTax(delta, base, bracketsObj){
    const b = Math.max(0, Number(base)  || 0);
    const d = Math.max(0, Number(delta) || 0);
    return Math.max(0, taxFromBrackets(b + d, bracketsObj) - taxFromBrackets(b, bracketsObj));
  }

  // --- exact allocator (with safety) ---
  function allocateByOrder(netNeed, balances, order, rrspFlat){
    let need = Math.max(0, netNeed);
    let {taxable:t, tfsa:f, rrsp:r} = balances;
    let fromTax=0, fromTFSA=0, fromRRSPGross=0, taxRRSP=0;

    for (const src of order) {
      if (need <= 0) break;
      if (src === "tfsa") {
        const draw = Math.min(need, f);
        fromTFSA += draw; f -= draw; need -= draw;
      } else if (src === "taxable") {
        const draw = Math.min(need, t);
        fromTax   += draw; t -= draw; need -= draw;
      } else if (src === "rrsp") {
        const flat = Math.max(0, Math.min(1, rrspFlat || 0));
        const netPossible = r * (1 - flat);
        const netTake     = Math.min(need, Math.max(0, netPossible));
        const gross       = netTake > 0 ? netTake / (1 - flat) : 0;
        const tax         = gross * flat;
        fromRRSPGross    += gross;
        taxRRSP          += tax;
        r                -= gross;
        need             -= netTake;
      }
    }
    if (need > 0 && t > 0) { // safety
      const draw = Math.min(need, t);
      fromTax += draw; t -= draw; need -= draw;
    }
    return {
      draws: { fromTax, fromTFSA, fromRRSPGross },
      taxes: { taxRRSP },
      shortfall: Math.max(0, need),
      endBalancesBeforeGrowth: { taxable:t, tfsa:f, rrsp:r }
    };
  }

  // ---------- exact copy of engine logic, parametric on order ----------
  function prerollToRetirementCopy(cfg) {
    let { current_age, retirement_age, return_rate, annual_saving, saving_increase_rate,
          taxable0, rrsp0, tfsa0, asset_liquidations } = cfg;

    let age = current_age;
    let taxable = taxable0, rrsp = rrsp0, tfsa = tfsa0;
    let save = annual_saving;

    const lm = liqMap(asset_liquidations);
    const d  = Math.max(0, Math.min(1, cfg.taxable_drag || 0));
    const gN = 1 + return_rate;
    const gT = 1 + return_rate * (1 - d);

    while (age < retirement_age) {
      const t0 = taxable;
      taxable = t0 * gT; rrsp *= gN; tfsa *= gN;
      taxable += save + (lm[age] || 0);
      save *= (1 + (cfg.saving_increase_rate||0));
      age += 1;
    }
    return { taxable, rrsp, tfsa };
  }

  function simulateEndTotalWithOrder(cfg, orderArr) {
    const lm = liqMap(cfg.asset_liquidations);
    const d  = Math.max(0, Math.min(1, cfg.taxable_drag || 0));
    const gN = 1 + cfg.return_rate_after;
    const gT = 1 + cfg.return_rate_after * (1 - d);

    const rrspFlat       = (cfg.income_tax_rate || 0);
    const bracketsOn     = !!(cfg.tax_brackets && (cfg.tax_brackets.enabled || cfg.tax_brackets.bands));
    const bracketsObj    = cfg.tax_brackets || null;

    let { taxable:t, rrsp:r, tfsa:f } = prerollToRetirementCopy(cfg);

    for (let age = cfg.retirement_age; age <= cfg.life_expectancy; age++){
      const expense = livingExpenseAtAge(cfg, age);
      const cpp     = cppAtAge(cfg, age);
      const oasG    = oasGrossAtAge(cfg, age);

      // first pass w/ OAS gross
      let pass = allocateByOrder(
        Math.max(0, expense - cpp - oasG),
        { taxable:t, tfsa:f, rrsp:r },
        orderArr,
        rrspFlat
      );

      // OAS clawback + top-up
      let incomeForClaw = pass.draws.fromRRSPGross + pass.draws.fromTax + oasG + cpp;
      let oasClaw = 0;
      if (cfg.oas_monthly>0 && cfg.oas_start_age>0 && age>=cfg.oas_start_age &&
          cfg.oas_threshold>0 && cfg.oas_clawback_rate>0){
        oasClaw = Math.max(0, incomeForClaw - cfg.oas_threshold) * cfg.oas_clawback_rate;
        oasClaw = Math.min(oasClaw, oasG);
      }
      if (oasClaw > 0){
        const top = allocateByOrder(oasClaw, pass.endBalancesBeforeGrowth, orderArr, rrspFlat);
        pass.draws.fromTax       += top.draws.fromTax;
        pass.draws.fromTFSA      += top.draws.fromTFSA;
        pass.draws.fromRRSPGross += top.draws.fromRRSPGross;
        pass.taxes.taxRRSP       += top.taxes.taxRRSP;
        pass.endBalancesBeforeGrowth = top.endBalancesBeforeGrowth;
      }

      // RRIF minimum
      if (cfg.rrif_start_age > 0 && age >= cfg.rrif_start_age){
        const mustGross = pass.endBalancesBeforeGrowth.rrsp * rrifMinPct(age);
        if (pass.draws.fromRRSPGross < mustGross){
          const extraGross = mustGross - pass.draws.fromRRSPGross;
          if (bracketsOn){
            const baseIncome = (cpp||0) + (oasG||0) + (pass.draws.fromRRSPGross||0);
            const extraTax   = incrementalTax(extraGross, baseIncome, bracketsObj);
            const extraNet   = extraGross - extraTax;
            pass.endBalancesBeforeGrowth.taxable += extraNet;
            pass.endBalancesBeforeGrowth.rrsp    -= extraGross;
            pass.__rrifMinTax = (pass.__rrifMinTax || 0) + extraTax;
          } else {
            const extraTax = extraGross * rrspFlat;
            const extraNet = extraGross - extraTax;
            pass.draws.fromRRSPGross += extraGross;
            pass.taxes.taxRRSP       += extraTax;
            pass.endBalancesBeforeGrowth.taxable += extraNet;
            pass.endBalancesBeforeGrowth.rrsp    -= extraGross;
          }
        }
      }

      // overlay rule
      let overlayTaxable = 0;
      if (bracketsOn){
        overlayTaxable = (d === 0) ? (pass.__rrifMinTax || 0) : 0;
      } else {
        const useOverlay = (d === 0) && (rrspFlat > 0);
        const grossUp    = useOverlay ? (rrspFlat / (1 - rrspFlat)) : 0;
        overlayTaxable   = useOverlay ? (pass.draws.fromTax * grossUp) : 0;
      }

      // pay overlay from taxable, then one-off liquidations
      let T = pass.endBalancesBeforeGrowth.taxable;
      let F = pass.endBalancesBeforeGrowth.tfsa;
      let R = pass.endBalancesBeforeGrowth.rrsp;

      T -= Math.min(overlayTaxable, Math.max(0, T));
      if (lm[age]) T += lm[age];

      // grow to end-of-year
      const T0 = T;
      T = T0 * gT;  F *= gN;  R *= gN;
      t = T; f = F; r = R;
    }

    return t + f + r; // End_Total at life expectancy
  }

  // --- vertical marker plugin for taxes chart ---
  const vlinePlugin = {
    id: "vline",
    afterDraw(chart, args, opts){
      const ages = (opts && opts.ages) || [];
      const {ctx, chartArea, scales} = chart;
      if (!scales?.x || !chartArea) return;
      ages.forEach(item=>{
        const x = scales.x.getPixelForValue(item.age);
        if (isFinite(x)){
          ctx.save();
          ctx.setLineDash([4,4]);
          ctx.strokeStyle = item.color || "#888";
          ctx.beginPath(); ctx.moveTo(x, chartArea.top); ctx.lineTo(x, chartArea.bottom); ctx.stroke();
          ctx.setLineDash([]); ctx.fillStyle = item.color || "#666";
          ctx.textAlign = "left"; ctx.textBaseline = "top"; ctx.font = "11px sans-serif";
          ctx.fillText(item.label, x + 4, chartArea.top + 4);
          ctx.restore();
        }
      });
    }
  };
  Chart.register(vlinePlugin);

  // ---------- main render hook ----------
  window.renderTaxCharts = function(rows, cfg){
    try{
      const ages     = rows.map(r => r.Age);
      const endT     = rows.map(r => num(r.End_Taxable));
      const endF     = rows.map(r => num(r.End_TFSA));
      const endR     = rows.map(r => num(r.End_RRSP));
      const endTot   = rows.map(r => num(r.End_Total));
      const rrifTax  = rows.map(r => num(r.Tax_On_Taxable));
      const taxRRSP  = rows.map(r => num(r.Tax_On_RRSP));
      const oasClaw  = rows.map(r => num(r.OAS_Clawback));

      // Effective tax on spending (%)
      const flatT = num(cfg?.income_tax_rate || 0);
      const fromTax  = rows.map(r => num(r.From_Taxable));
      const fromTFSA = rows.map(r => num(r.From_TFSA));
      const fromRRSP = rows.map(r => num(r.From_RRSP_Gross));
      const rrspNet  = fromRRSP.map(v => v * (1 - flatT));
      const netSpend = fromTax.map((v,i)=> v + fromTFSA[i] + rrspNet[i]);
      const effTaxOnSpend = netSpend.map((s,i)=> {
        const tax = num(rrifTax[i]) + num(taxRRSP[i]) + num(oasClaw[i]);
        return s>0 ? (tax/s*100) : 0;
      });

      // canvases
      const cOrders = document.getElementById("taxviz_orders");
      const cTaxes  = document.getElementById("taxviz_taxes");
      const cBal    = document.getElementById("taxviz_balances");
      if (!cOrders || !cTaxes || !cBal) return;

      // destroy old charts
      ["__taxC1","__taxC2","__taxC3"].forEach(k => { try{ window[k]?.destroy(); }catch(e){} });

      // (1) BAR: simulate all orders using the SAME logic as the table
      const orderKeys = Object.keys(ORDER_MAP);
      const eoLifeRaw = orderKeys.map(k => simulateEndTotalWithOrder(cfg, ORDER_MAP[k]));
      const eoLife    = eoLifeRaw.map(Math.round);

      const bestIdx = eoLifeRaw.indexOf(Math.max.apply(null, eoLifeRaw));
      const worstIdx= eoLifeRaw.indexOf(Math.min.apply(null, eoLifeRaw));
      const bestTxt = `${mFmt0(eoLifeRaw[bestIdx])} (best: ${ORDER_LABEL[orderKeys[bestIdx]]})`;
      const worstTxt= `${mFmt0(eoLifeRaw[worstIdx])} (worst: ${ORDER_LABEL[orderKeys[worstIdx]]})`;

      window.__taxC1 = new Chart(cOrders.getContext("2d"), {
        type: "bar",
        data: { labels: orderKeys.map(k => ORDER_LABEL[k]), datasets: [{ label: "End Total at lifespan end", data: eoLife }] },
        options: {
          responsive:false, maintainAspectRatio:false, devicePixelRatio:1, animation:false,
          onClick(evt){
            const pts = window.__taxC1.getElementsAtEventForMode(evt, "nearest", {intersect:true}, true);
            if (!pts?.length) return;
            const idx = pts[0].index, key = orderKeys[idx];
            const sel = document.getElementById("wd_order");
            if (sel) { sel.value = key; sel.dispatchEvent(new Event("change", {bubbles:true})); }
            else { document.getElementById("litev1_run")?.click(); }
          },
          scales:{ y:{ beginAtZero:false, title:{display:true,text:"$ at age " + cfg.life_expectancy}, ticks:{ callback:kFmt } } },
          plugins:{
            legend:{position:"top"},
            title:{display:true, text:`${bestTxt}   vs   ${worstTxt}`},
            subtitle:{display:true, text:"🌟Tip: bars are clickable — click a bar to switch the withdrawal order", color:"#6c757d", font:{size:11}},
            tooltip:{ callbacks:{ label:(ctx)=> ` ${ctx.dataset.label}: ${intFmt(ctx.parsed.y)}` } }
          }
        }
      });

      // (2) TAXES
      window.__taxC2 = new Chart(cTaxes.getContext("2d"), {
        data: {
          labels: ages,
          datasets: [
            { type:"bar",  label:"Tax on Taxable (overlay)", data: rrifTax, stack:"tax" },
            { type:"bar",  label:"Tax on RRSP (overlay)",    data: taxRRSP, stack:"tax" },
            { type:"bar",  label:"OAS Clawback",             data: oasClaw, stack:"tax" },
            { type:"line", label:"Effective tax on spending (%)", data: effTaxOnSpend, yAxisID:"y1" }
          ]
        },
        options: {
          responsive:false, maintainAspectRatio:false, devicePixelRatio:1, animation:false,
          scales:{
            y:  { beginAtZero:true, title:{display:true,text:"$ / year"}, ticks:{ callback:(v)=>kFmt(v) } },
            y1: { position:"right", grid:{drawOnChartArea:false}, title:{display:true,text:"%"} }
          },
          plugins:{
            legend:{position:"top"},
            vline:{ ages:[ {age:65,label:"65: OAS starts",color:"#999"}, {age:72,label:"72: RRIF min starts",color:"#999"} ] }
          }
        }
      });

      // (3) BALANCES
    window.__taxC3 = new Chart(cBal.getContext("2d"), {
      type: "line",
      data: {
        labels: ages,
        datasets: [
          // make these very thin + no points
          { label: "End Taxable", data: endT, borderWidth: 1, pointRadius: 0.25, pointHoverRadius: 3, pointHitRadius: 6 },
          { label: "End TFSA",    data: endF, borderWidth: 1, pointRadius: 0.25, pointHoverRadius: 3, pointHitRadius: 6 },
          { label: "End RRSP",    data: endR, borderWidth: 1, pointRadius: 0.25, pointHoverRadius: 3, pointHitRadius: 6 },

          // keep End Total emphasized
          { label: "End Total",   data: endTot, borderWidth: 3, pointRadius: 2, pointHoverRadius: 4, pointHitRadius: 8 }
        ]
      },
      options: {
        responsive:false, maintainAspectRatio:false, devicePixelRatio:1, animation:false,
        scales:{ y:{ position:"right", beginAtZero:false, title:{display:true,text:"$"}, ticks:{ callback:kFmt } } },
        plugins:{ legend:{position:"top"}, tooltip:{ callbacks:{ label:(ctx)=> ` ${ctx.dataset.label}: ${intFmt(ctx.parsed.y)}` } } }
      }
    });
    } catch(e){ /* never block */ }
  };
})();
</script>


<!-- ---------- show/hide the hint for Taxable Drag (%) row automatically ---------- -->
<script>
(function setupBracketDragHint(){
  const bracketIds = ['tb_lim1','tb_lim2','tb_rate1','tb_rate2','tb_rate3'];
  const helperIds  = ['td_a_div','td_y_div','td_t_div',
                      'td_a_int','td_y_int','td_t_int',
                      'td_a_cg','td_y_cg','td_t_cg'];
  const dragInput  = document.getElementById('litev1_taxable_drag');
  const impliedEl  = document.getElementById('td_implied');
  const hint       = document.getElementById('drag_hint');
  const autoChk    = document.getElementById('td_auto_apply');

  // If the hint element isn't on this page, bail quietly.
  if (!hint) return;

  function bracketsOn(){
    return bracketIds.some(id => {
      const el = document.getElementById(id);
      return el && (+el.value > 0);
    });
  }

  function parsePctFromEl(el){
    if (!el) return 0;
    const txt = (el.textContent || el.innerText || '').replace(/[%\s]/g,'');
    const v = parseFloat(txt);
    return Number.isFinite(v) ? v : 0;
  }

  function updateHint(){
    const on       = bracketsOn();
    const implied  = parsePctFromEl(impliedEl);      // e.g., "7.50%" -> 7.5
    const dragVal  = parseFloat(dragInput?.value || '0');
    const nearZero = Math.abs(implied) < 0.01 && Math.abs(dragVal) < 0.01; // treat <0.01% as zero
    hint.style.display = (on && nearZero) ? '' : 'none';
  }

  // React to user edits on bracket and helper fields, drag input, and auto-apply toggle
  [...bracketIds, ...helperIds, 'litev1_taxable_drag','td_auto_apply'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('input',  updateHint);
      el.addEventListener('change', updateHint);
    }
  });

  // Also react when code updates the implied cell text
  if (impliedEl && 'MutationObserver' in window) {
    new MutationObserver(updateHint).observe(impliedEl, { childList:true, characterData:true, subtree:true });
  }

  updateHint(); // init
})();
</script>



<!-- ---------- Adds a live guardrail: “Allocated $X of $Y (Z%)” ---------- -->
<script>
(function setupBalancesGuardrail(){
  if (window.__balancesGuardrailSetup) return; window.__balancesGuardrailSetup = true;

  const elCard  = document.getElementById('litev1_card');
  const tEl     = document.getElementById('litev1_taxable');
  const rEl     = document.getElementById('litev1_rrsp');
  const fEl     = document.getElementById('litev1_tfsa');
  const totalEl = document.getElementById('acct_total');
  const vsEl    = document.getElementById('acct_vs');
  const guardEl = document.getElementById('acct_guard');

  if (!tEl || !rEl || !fEl || !totalEl || !guardEl) return;

  // ---- helpers
  const fmt = v => '$' + Math.round(v).toLocaleString();
  const num = s => {
    const cleaned = String(s ?? '').replace(/[^\d.-]/g, '');
    const n = parseFloat(cleaned);
    return Number.isFinite(n) ? n : 0;
  };

  // Read Top inputs total (preferred sources)
  const readTopTotal = () => {
    const fromAttr = num(elCard?.dataset?.topAssets);
    if (fromAttr > 0) return fromAttr;
    const fromWin  = num(window.__topAssetsTotal);
    if (fromWin > 0) return fromWin;
    return 0;
  };

  // Baseline starts from Top inputs if available, else 0 (we'll settle soon)
  let baseline = readTopTotal();

  // Track if the user has started editing (so we don't rebaseline from their typing)
  let userTouched = false;
  [tEl, rEl, fEl].forEach(el => {
    el.addEventListener('input', () => { userTouched = true; update(); });
    el.addEventListener('change', () => { userTouched = true; update(); });
    el.addEventListener('keyup',  () => { userTouched = true; update(); });
  });

  // Settle window: for the first ~1.2s, if Top inputs push a value or Taxable
  // gets programmatically set (and user hasn't typed yet), adopt that as baseline.
  const t0 = Date.now();
  const settleTimer = setInterval(() => {
    const now = Date.now();
    const topNow = readTopTotal();
    if (topNow > 0 && topNow !== baseline) {
      baseline = topNow;
      update();
    } else if (!baseline && !userTouched) {
      const maybeFromTaxable = num(tEl.value);
      if (maybeFromTaxable > 0) {
        baseline = maybeFromTaxable;
        update();
      }
    }
    if (now - t0 > 1200) clearInterval(settleTimer);
  }, 120);

  // Also allow explicit re-baselining when Top inputs change
  window.addEventListener('topAssets:changed', () => {
    const topNow = readTopTotal();
    if (topNow > 0) baseline = topNow;
    update();
  });

  function update(){
    // LEFT = live sum of A+B+C
    const sum = num(tEl.value) + num(rEl.value) + num(fEl.value);
    totalEl.textContent = fmt(sum);

    // RIGHT = Top inputs total (baseline)
    const pct = baseline > 0 ? (sum / baseline) * 100 : 100;
    vsEl.textContent = baseline > 0 ? ` of ${fmt(baseline)} (${pct.toFixed(1)}%)` : '';

    // Guardrail text
    const tol = Math.max(1, baseline * 0.001); // ~0.1% or $1
    const ok  = baseline > 0 ? Math.abs(sum - baseline) <= tol : true;
    guardEl.className  = 'small ' + (ok ? 'text-success' : 'text-danger');
    guardEl.textContent = ok
      ? '✓ Total matches your current assets.'
      : 'Total should equal your current assets (100%). Adjust the amounts above.';
  }

  update(); // initial render
})();
</script>





<!-- === Optimizer (OAS gated/capped + explicit E override & base override + open-balance debug) ==== -->
<script>
(function () {
  "use strict";

  // ---------------- tiny DOM helpers ----------------
  const $ = (id) => document.getElementById(id);

  // robust writer: try several candidate selectors
  function pickEl(...cands) {
    for (const c of cands) {
      const el = (c[0] === "#" || c.startsWith("[") || c.startsWith("."))
        ? document.querySelector(c)
        : document.getElementById(c);
      if (el) return el;
    }
    return null;
  }
  function writeTo(slot, text) {
    const el = pickEl(slot, `#${slot}`, `[data-slot="${slot}"]`, `[data-id="${slot}"]`, `.${slot}`);
    if (el) el.textContent = String(text);
  }

  // ---------- numeric helpers ----------
  const toNum = (x) => Number(String(x ?? "").replace(/[^0-9.\-]/g, "")) || 0;
  const readNumber = (el) => (el ? toNum(el.value) : 0);

  // first numeric from a list of selectors
  const firstNum = (selectors) => {
    for (const sel of selectors) {
      const el = document.querySelector(sel);
      if (!el) continue;
      const v =
        (el.tagName === "INPUT" || el.tagName === "SELECT" || el.tagName === "TEXTAREA")
          ? el.value
          : (el.getAttribute("value") ?? el.textContent);
      const n = toNum(v);
      if (Number.isFinite(n)) return n;
    }
    return 0;
  };

  // read percentage (0–100) from any of several ids/names and return decimal (0–1)
  function readPctMulti(cands) {
    for (const key of cands) {
      let el = document.getElementById(key);
      if (!el) el = document.querySelector(`#${key},[name="${key}"]`);
      if (!el) continue;
      const raw = (el.value ?? "").toString().trim();
      if (raw === "") continue;
      const v = Number(raw.replace(/,/g, ""));
      if (Number.isFinite(v)) return Math.max(0, v) / 100;
    }
    return 0;
  }

  // ---------------- tax helpers ----------------
  function readBracketsFromUI() {
    const v = (id) => {
      const el = $(id);
      if (!el) return NaN;
      const n = Number((el.value || "").replace(/,/g, ""));
      return Number.isFinite(n) ? n : NaN;
    };
    const lim1 = v("tb_lim1"), lim2 = v("tb_lim2"),
          r1 = v("tb_rate1"), r2 = v("tb_rate2"), r3 = v("tb_rate3");

    const allZero = [lim1, lim2, r1, r2, r3].every(x => !Number.isFinite(x) || x === 0);
    if (allZero) return null;

    const L1 = Number.isFinite(lim1) && lim1 > 0 ? lim1 : 50000;
    const L2 = Math.max(L1, Number.isFinite(lim2) && lim2 > 0 ? lim2 : 100000);

    return {
      enabled: true,
      bands: [
        { limit: L1,       rate: ((Number.isFinite(r1) ? r1 : 10) / 100) },
        { limit: L2,       rate: ((Number.isFinite(r2) ? r2 : 20) / 100) },
        { limit: Infinity, rate: ((Number.isFinite(r3) ? r3 : 30) / 100) },
      ],
    };
  }
  function taxFromBr(inc, br) {
    if (!br || !br.bands) return 0.30 * Math.max(0, inc || 0);
    let tax = 0, prev = 0, I = Math.max(0, inc || 0);
    for (const b of br.bands) {
      const upto = Math.min(I, b.limit);
      if (upto > prev) tax += (upto - prev) * (b.rate || 0);
      if (I <= b.limit) return tax;
      prev = b.limit;
    }
    const last = br.bands[br.bands.length - 1];
    return tax + Math.max(0, I - prev) * (last.rate || 0);
  }
  function incrTax(d, b, br, flat) { // incremental tax on delta d at base b
    d = Math.max(0, d || 0);
    b = Math.max(0, b || 0);
    if (br && (br.enabled || br.bands)) return Math.max(0, taxFromBr(b + d, br) - taxFromBr(b, br));
    return d * Math.max(0, Math.min(0.90, (flat || 0)));
  }
  function grossForNet(netNeed, base, br, flat, maxGross){
    netNeed = Math.max(0, netNeed || 0);
    const netFn = (g) => Math.max(0, g - incrTax(g, base, br, flat));
    if (netNeed <= 0) return {gross:0, tax:0, net:0};
    let lo = 0, hi = Math.min(Math.max(1, netNeed * 1.3), maxGross || Infinity);
    let nHi = netFn(hi);
    while (nHi < netNeed - 0.01 && hi < (maxGross || Infinity)) {
      lo = hi;
      hi = Math.min((maxGross || hi * 2), hi * 1.8 + 1);
      const n = netFn(hi);
      if (hi <= lo + 1) { nHi = n; break; }
      nHi = n;
    }
    for (let i = 0; i < 30; i++) {
      const mid = (lo + hi) / 2;
      const n = netFn(mid);
      if (n >= netNeed) hi = mid; else lo = mid;
    }
    const gross = Math.min(hi, maxGross || hi);
    const tax = incrTax(gross, base, br, flat);
    const net = Math.max(0, gross - tax);
    return { gross, tax, net };
  }

  // ---------- STRICT asset-liquidation reader ----------
  function readAssetLiquidationsStrict() {
    const liqs = [];
    const ageKeys = (i) => [
      `#asset_liquidation_age_${i}`, `[name="asset_liquidation_age_${i}"]`,
      `#asset_liquidation_age${i}`,   `[name="asset_liquidation_age${i}"]`,
      `#asset_liq_age_${i}`,          `[name="asset_liq_age_${i}"]`,
      `#asset_liq_age${i}`,           `[name="asset_liq_age${i}"]`,
    ];
    const amtKeys = (i) => [
      `#asset_liquidation_${i}`, `[name="asset_liquidation_${i}"]`,
      `#asset_liquidation${i}`,  `[name="asset_liquidation${i}"]`,
      `#asset_liq_${i}`,         `[name="asset_liq_${i}"]`,
      `#asset_liq${i}`,          `[name="asset_liq${i}"]`,
    ];
    for (let i = 1; i <= 6; i++) {
      const age = firstNum(ageKeys(i));
      const amt = firstNum(amtKeys(i));
      if (age > 0 && amt !== 0) liqs.push({ age, amount: amt });
    }
    return liqs;
  }

  // ---------- STRICT CPP reader ----------
  function readCPPStrict(defaultEndAge) {
    const amountSelectors = [
      '#cpp_monthly','[name="cpp_monthly"]',
      '#cpp_support','[name="cpp_support"]',
      '#support_cpp','[name="support_cpp"]',
      '#support_monthly','[name="support_monthly"]',
      '#living_expense_support','[name="living_expense_support"]',
      '#cpp_mo','[name="cpp_mo"]',
      '#cpp','[name="cpp"]'
    ];
    const startSelectors = [
      '#cpp_start_age','[name="cpp_start_age"]',
      '#cpp_age_start','[name="cpp_age_start"]',
      '#cpp_age','[name="cpp_age"]',
      '#cpp_from_age','[name="cpp_from_age"]',
      '#extended_year_from','[name="extended_year_from"]',
      '#extended_from_age','[name="extended_from_age"]',
      '#ext_year_from_age','[name="ext_year_from_age"]',
      '#ext_from_age','[name="ext_from_age"]'
    ];
    const endSelectors = [
      '#cpp_end_age','[name="cpp_end_age"]',
      '#cpp_age_end','[name="cpp_age_end"]',
      '#cpp_to_age','[name="cpp_to_age"]',
      '#extended_year_to','[name="extended_year_to"]',
      '#extended_to_age','[name="extended_to_age"]',
      '#ext_year_to_age','[name="ext_year_to_age"]',
      '#ext_to_age','[name="ext_to_age"]'
    ];
    const monthly = firstNum(amountSelectors) || 0;
    const startIn = firstNum(startSelectors);
    const endIn   = firstNum(endSelectors);
    const startAge = (Number.isFinite(startIn) && startIn > 0) ? startIn : 65;
    const theEnd  = Number.isFinite(endIn) && endIn > 0 ? endIn : (defaultEndAge || startAge);
    return { cpp_monthly: monthly, cpp_start_age: startAge, cpp_end_age: theEnd };
  }

  // ---------------- DOM helpers ----------------
  const numMulti = (...selectors) => {
    for (const sel of selectors) {
      let el = document.getElementById(sel);
      if (!el) el = document.querySelector(sel.startsWith("#") || sel.startsWith("[") ? sel : `#${sel},[name="${sel}"]`);
      if (el) return readNumber(el);
    }
    return 0;
  };

  // ---------------- config ----------------
  function buildCfgLight() {
    const num  = (id) => { const el = $(id); if (!el) return 0; const s = (el.value || "").replace(/,/g, "").trim(); const v = Number(s); return Number.isFinite(v) ? v : 0; };
    const bool = (id) => !!$(id)?.checked;

    const current_age = num("litev1_start_age");
    const end_age     = num("litev1_end_age");

    const retEl = document.getElementById("retirement_age") || document.querySelector('[name="retirement_age"]');
    const retirement_age = (() => {
      const raw = (retEl?.value ?? "").toString().replace(/,/g, "").trim();
      const v   = Number(raw);
      return (Number.isFinite(v) && v > 0) ? v : current_age;
    })();

    const pre_tfsa_annual = numMulti("pre_tfsa_annual", "tfsa_annual", "litev1_tfsa_annual");
    const pre_rrsp_annual = numMulti("pre_rrsp_annual", "rrsp_annual", "litev1_rrsp_annual");

    const asset_liquidations = readAssetLiquidationsStrict();
    const { cpp_monthly, cpp_start_age, cpp_end_age } = readCPPStrict(end_age);

    const saving_increase_rate = readPctMulti([
      "saving_increase_rate","annual_saving_increase_rate","annual_savings_increase_rate",
      "savings_increase_rate","saving_increase","savings_increase",
      "saving_rate_increase","monthly_saving_increase_rate","msaving_increase_rate"
    ]);

    const taxable_drag   = (Number(document.getElementById("litev1_taxable_drag")?.value) || 0) / 100;
    const return_rate    = (num("litev1_return") || 0) / 100;
    const return_rate_after =
      (Number(document.getElementsByName("return_rate_after")?.[0]?.value
        || document.getElementById("return_rate_after")?.value
        || num("litev1_return")) || 0) / 100;

    const income_tax_rate = (num("litev1_income_tax") || 0) / 100;

    // OAS – optional overrides
    const oas_tax_inc_fixed     = numMulti("oas_tax_inc_fixed","oas_taxable_income_for_oas","oas_E");
    const oas_tax_base_override = numMulti("oas_tax_base_override","oas_E_base");

    return {
      current_age, life_expectancy: end_age, retirement_age,
      start_year: new Date().getFullYear(),

      taxable0: num("litev1_taxable"),
      rrsp0:    num("litev1_rrsp"),
      tfsa0:    num("litev1_tfsa"),

      annual_saving: (num("litev1_monthly_saving") || 0) * 12,
      saving_increase_rate,

      pre_tfsa_annual, pre_rrsp_annual,

      annual_expense: (num("litev1_spend") || 0) * 12,
      return_rate, return_rate_after, inflation_rate: (Number(document.getElementById("inflation_rate")?.value) || 2) / 100,

      tax_brackets: readBracketsFromUI(),
      income_tax_rate,

      cpp_monthly, cpp_start_age, cpp_end_age,

      oas_monthly: num("oas_mo"),
      oas_start_age: num("oas_start_age"),
      oas_threshold: num("oas_threshold"),
      oas_clawback_rate: (Number(document.getElementById("oas_rate")?.value) || 0) / 100,
      oas_index: bool("oas_index"),

      rrif_start_age: num("rrif_start_age"),
      taxable_drag,

      tfsa_cagr_after_2025: 0.021,

      oas_tax_inc_fixed,
      oas_tax_base_override,

      asset_liquidations
    };
  }

  // ---------------- helpers ----------------
  function rrifMinPct(age){
    const t = {71:0.0528,72:0.0540,73:0.0553,74:0.0567,75:0.0582,76:0.0598,77:0.0617,78:0.0636,79:0.0658,
               80:0.0682,81:0.0708,82:0.0738,83:0.0771,84:0.0808,85:0.0851,86:0.0899,87:0.0955,88:0.1021,
               89:0.1099,90:0.1192,91:0.1306,92:0.1449,93:0.1634,94:0.1879};
    if (age >= 95) return 0.20;
    if (age >= 71) return t[age] || 0;
    return 1 / (90 - age);
  }
  function oasGrossAtAge(cfg, age){
    if (!cfg.oas_monthly || !cfg.oas_start_age || age < cfg.oas_start_age) return 0;
    const yrs = Math.max(0, age - cfg.oas_start_age);
    const f = cfg.oas_index ? Math.pow(1 + cfg.inflation_rate, yrs) : 1;
    return cfg.oas_monthly * 12 * f;
  }
  function livingExpenseAtAge(cfg, age){
    const n = Math.max(0, age - cfg.current_age);
    return (cfg.annual_expense || 0) * Math.pow(1 + (cfg.inflation_rate || 0), n);
  }
  function within(x,a,b){ return x>=a && x<=b; }
  function cppAtAge(cfg, age){
    if (!(cfg.cpp_monthly > 0) || !within(age, cfg.cpp_start_age, cfg.cpp_end_age)) return 0;
    const n = Math.max(0, age - cfg.cpp_start_age);
    return (cfg.cpp_monthly * 12) * Math.pow(1 + (cfg.inflation_rate || 0), n);
  }
  function liqMap(liqs){
    const m = {};
    (liqs || []).forEach(x => {
      const a = Number(x.age || -1), v = Number(x.amount || 0);
      if (a >= 0 && v) m[a] = (m[a] || 0) + v;
    });
    return m;
  }

  // === OAS: taxable *investment income* (E) with override and optional base override
  // baseForProxy is the balance we want to treat as producing taxable investment income
  function computeTaxIncForOAS(baseForProxy, cfg) {
    const flat = Math.max(0, Math.min(0.90, cfg.income_tax_rate || 0));
    const rA   = Math.max(0, cfg.return_rate_after || 0);
    const drag = Math.max(0, Math.min(1, cfg.taxable_drag || 0));

    // 1) Hard override for E
    const fixed = Math.max(0, Number(cfg.oas_tax_inc_fixed || 0));
    if (fixed > 0) return { E: fixed, method: "fixed", baseUsed: fixed, rAfter: rA, drag, flat };

    // 2) Balance override for the proxy base (else use provided baseForProxy)
    const base = Math.max(0, Number(cfg.oas_tax_base_override || baseForProxy || 0));

    const taxDollars = base * rA * drag;
    const proxyE = flat > 0 ? (taxDollars / flat) : 0;
    return { E: proxyE, method: (cfg.oas_tax_base_override ? "proxy(base-override)" : "proxy"),
             baseUsed: base, rAfter: rA, drag, flat };
  }

  // ---------------- pre-retirement build ----------------
  function buildPreRetRows(cfg) {
    const rows = [];
    let age = cfg.current_age;
    const rAge = cfg.retirement_age;

    let taxable = Number(cfg.taxable0 || 0);
    let rrsp    = Number(cfg.rrsp0 || 0);
    let tfsa    = Number(cfg.tfsa0 || 0);

    const d  = Math.max(0, Math.min(1, cfg.taxable_drag || 0));
    const gN = 1 + (cfg.return_rate || 0);
    const gT = 1 + (cfg.return_rate || 0) * (1 - d);

    let save = Number(cfg.annual_saving || 0);
    const lm  = liqMap(cfg.asset_liquidations);

    while (age < rAge) {
      const t_before = taxable;
      const taxDrag  = t_before * (cfg.return_rate || 0) * d;

      taxable *= gT; rrsp *= gN; tfsa *= gN;

      const year     = Number(cfg.start_year) + (age - Number(cfg.current_age));
      const tfsa_cap = (() => {
        const base = Math.max(0, cfg.pre_tfsa_annual || 0);
        if (year <= 2025) return base;
        const yrs = Math.max(0, year - 2025);
        return base * Math.pow(1 + cfg.tfsa_cagr_after_2025, yrs);
      })();
      const rrsp_cap = Math.max(0, cfg.pre_rrsp_annual || 0);
      const to_tfsa  = Math.min(save, tfsa_cap);
      const after_tf = Math.max(0, save - to_tfsa);
      const to_rrsp  = Math.min(after_tf, rrsp_cap);
      const to_tax   = Math.max(0, after_tf - to_rrsp);

      tfsa += to_tfsa; rrsp += to_rrsp; taxable += to_tax;

      const liq = lm[age] || 0;
      if (liq) taxable += liq;

      rows.push({
        Age: age,
        From_Taxable_Gross: 0, From_TFSA: 0, From_RRSP_Gross: 0,
        Tax_On_Taxable: 0, Tax_On_RRSP: 0,
        RRIF_Min_Pct: "0.00%", CPP: 0, OAS_Gross: 0, OAS_Clawback: 0, OAS_Net: 0,
        Living_Expense: 0, CPP_Extra: 0, Income_Tax_Payment: 0, Living_Exp_Ret: 0,
        Contrib_Taxable: Math.round(to_tax), Contrib_TFSA: Math.round(to_tfsa), Contrib_RRSP: Math.round(to_rrsp),
        Liq_Added: Math.round(liq),
        Taxable_Drag: Math.round(taxDrag),
        Open_Taxable: "", Open_TFSA: "", Open_RRSP: "",
        OAS_Base: 0, OAS_Base_CPP: 0, OAS_Base_RRSP: 0, OAS_Base_TaxInc: 0,
        OAS_TaxInc_Method: "", OAS_TaxInc_openT: "", OAS_TaxInc_baseUsed: "",
        OAS_TaxInc_rAfter: "", OAS_TaxInc_drag: "", OAS_TaxInc_flat: "",
        OAS_Threshold: "", OAS_Rate: "", OAS_Claw_raw: "", OAS_Claw_capped: "",
        End_Taxable: Math.round(taxable), End_TFSA: Math.round(tfsa), End_RRSP: Math.round(rrsp),
        End_Total_Raw: Math.round(taxable + tfsa + rrsp), Cum_Tax_On_Taxable: 0,
        End_Total: Math.round(taxable + tfsa + rrsp)
      });

      save *= (1 + (cfg.saving_increase_rate || 0));
      age += 1;
    }
    return rows;
  }

  // ---------------- CSV ----------------
  function toCSV(rows, cols) {
    if (!rows?.length) return "";
    const esc = (s) => `"${String(s ?? "").replace(/"/g, '""')}"`;
    const header = cols.join(",");
    const body = rows.map((r) => cols.map((c) => esc(r[c])).join(",")).join("\n");
    return header + "\n" + body;
  }
  const CSV_COLS = [
    "Age",
    "Contrib_Taxable","Contrib_TFSA","Contrib_RRSP","Liq_Added","CPP_Extra",
    "CPP","OAS_Gross","OAS_Clawback","OAS_Net",
    "Living_Expense","Income_Tax_Payment","Living_Exp_Ret",
    "From_Taxable_Gross","From_TFSA","RRIF_Min_Pct","From_RRSP_Gross",
    "Tax_On_Taxable","Tax_On_RRSP","Taxable_Drag",
    "Open_Taxable","Open_TFSA","Open_RRSP",
    "OAS_Base","OAS_Base_CPP","OAS_Base_RRSP","OAS_Base_TaxInc",
    "OAS_TaxInc_Method","OAS_TaxInc_openT","OAS_TaxInc_baseUsed","OAS_TaxInc_rAfter","OAS_TaxInc_drag","OAS_TaxInc_flat",
    "OAS_Threshold","OAS_Rate","OAS_Claw_raw","OAS_Claw_capped",
    "End_Taxable","End_TFSA","End_RRSP","End_Total_Raw","Cum_Tax_On_Taxable","End_Total"
  ];

  // ---------------- Next-$1 (display only) ----------------
  function nextDollar() {
    const cfg  = buildCfgLight();
    const age  = cfg.retirement_age;
    const br   = cfg.tax_brackets;

    const cpp = cppAtAge(cfg, age);
    const oas = oasGrossAtAge(cfg, age);
    const baseIncome = cpp + oas;

    const rr_tax = incrTax(1000, baseIncome, br, cfg.income_tax_rate) / 1000;
    writeTo("n1_rrsp", `RRSP marginal ≈ ${(rr_tax*100).toFixed(1)}%`);
    writeTo("n1_taxable", `Taxable effective ≈ ${(cfg.income_tax_rate*100).toFixed(1)}% (flat)`);
    writeTo("n1_oas", (cfg.oas_monthly>0)
      ? `OAS clawback uses CPP + RRSP(g) + taxable investment income (E)`
      : `OAS not in play`);
    writeTo("n1_hint", "You can override E directly (oas_E) or the proxy base (oas_E_base).");
  }

  // --------- one-year simulator GIVEN an OAS net value + order ---------
  function simulateYearOrderGivenOASNet(params){
    const {
      age, cfg, openT, openF, openR,
      oasGross, oasNet,
      order, tfsa_prefill_net,
      lmRet, rAfter, drag, gN, gT, flatRate, br, bracketsOn
    } = params;

    const living   = livingExpenseAtAge(cfg, age);
    const cppInc   = cppAtAge(cfg, age);
    let netNeed    = Math.max(0, living - cppInc - oasNet);

    // Optional TFSA prefill (NET)
    let fromTFSA = 0;
    let fAvail   = openF;
    if (netNeed > 0 && fAvail > 0 && tfsa_prefill_net > 0) {
      const pre = Math.min(netNeed, Math.min(fAvail, tfsa_prefill_net));
      fromTFSA += pre; netNeed -= pre; fAvail -= pre;
    }

    let fromTax_NET = 0, fromTax_GROSS_FOR_TABLE = 0, taxOnTaxable = 0;
    let fromRRSP_GROSS = 0, taxOnRRSP = 0;
    let rrifPct = 0, extraTaxFromRRIFMin = 0, extraNetFromRRIFMin = 0;

    let tAvail = openT, rAvail = openR;

    const takeFromTaxable = () => {
      if (netNeed <= 0 || tAvail <= 0) return;
      if (bracketsOn) {
        const g = grossForNet(netNeed, /*base*/0, br, flatRate, tAvail);
        const net = Math.min(netNeed, g.net);
        fromTax_NET             += net;
        fromTax_GROSS_FOR_TABLE += Math.min(tAvail, g.gross);
        tAvail                  -= g.gross;
        netNeed                 -= net;
      } else {
        const take = Math.min(netNeed, tAvail);
        fromTax_NET             += take;
        fromTax_GROSS_FOR_TABLE += take;
        tAvail                  -= take;
        netNeed                 -= take;
        taxOnTaxable           += flatRate > 0 ? (take * (flatRate / (1 - flatRate))) : 0;
      }
    };
    const takeFromTFSA = () => {
      if (netNeed <= 0 || fAvail <= 0) return;
      const take = Math.min(netNeed, fAvail);
      fromTFSA += take; fAvail -= take; netNeed -= take;
    };
    const takeFromRRSP = () => {
      if (netNeed <= 0 || rAvail <= 0) return;
      if (bracketsOn) {
        const g = grossForNet(netNeed, /*base*/0, br, flatRate, rAvail);
        fromRRSP_GROSS += g.gross;
        taxOnRRSP      += g.tax;
        rAvail         -= g.gross;
        netNeed        -= g.net;
      } else {
        const netPossible = rAvail * (1 - flatRate);
        const netTake     = Math.min(netNeed, Math.max(0, netPossible));
        const gross       = netTake > 0 ? netTake / (1 - flatRate) : 0;
        const g           = Math.min(rAvail, gross);
        fromRRSP_GROSS += g; taxOnRRSP += g * flatRate; rAvail -= g; netNeed -= netTake;
      }
    };

    for (const ch of order) {
      if (netNeed <= 0) break;
      if (ch === 'T') takeFromTaxable();
      else if (ch === 'F') takeFromTFSA();
      else takeFromRRSP();
    }

    // RRIF minimum (force extra gross; net flows to taxable)
    if (cfg.rrif_start_age > 0 && age >= cfg.rrif_start_age && (openR > 0)) {
      rrifPct = rrifMinPct(age);
      const rrspLeftBeforeGrowth = Math.max(0, openR - fromRRSP_GROSS);
      const mustGross = rrspLeftBeforeGrowth * rrifPct;
      if (mustGross > 0) {
        const extraTax = bracketsOn ? incrTax(mustGross, 0, br, flatRate) : mustGross * flatRate;
        const extraNet = mustGross - extraTax;
        extraTaxFromRRIFMin = extraTax;
        extraNetFromRRIFMin = extraNet;
        fromRRSP_GROSS += mustGross;
      }
    }

    // Pre-growth balances
    let tAfter = openT - fromTax_NET;
    let fAfter = openF - fromTFSA;
    let rAfterBal = openR - fromRRSP_GROSS;

    // RRIF-min net lands in taxable (pre-growth)
    tAfter += extraNetFromRRIFMin;
    taxOnRRSP += extraTaxFromRRIFMin;

    if (!bracketsOn && drag === 0 && taxOnTaxable > 0) {
      tAfter -= Math.min(tAfter, taxOnTaxable);
    }

    // Asset liquidation BEFORE growth (ret years)
    const lm = lmRet;
    const liq = Number(lm[age] || lm[String(age)] || 0);
    if (liq) tAfter += liq;

    // Growth (and display-only tax drag for this year)
    const taxDragAmt = Math.max(0, tAfter) * rAfter * drag; // display only
    const endTaxable = Math.max(0, tAfter) * (1 + rAfter * (1 - drag));
    const endTFSA    = Math.max(0, fAfter) * (1 + rAfter);
    const endRRSP    = Math.max(0, rAfterBal) * (1 + rAfter);

    const incomeTaxPayment = Math.round(taxOnTaxable + taxOnRRSP);

    return {
      living, cppInc,
      fromTax_GROSS_FOR_TABLE, fromTFSA, fromRRSP_GROSS,
      taxOnTaxable, taxOnRRSP, rrifPct,
      liq, taxDragAmt,
      endTaxable, endTFSA, endRRSP,
      incomeTaxPayment,
      tAfter, fAfter, rAfterBal,
      extraNetFromRRIFMin
    };
  }

  // ---------------- Optimizer ----------------
  async function runOptimizerIfEnabled() {
    const write = (id, text) => writeTo(id, text);

    try {
      const toggle = document.getElementById("opt_toggle");
      // Only skip when the toggle exists AND is OFF. If it's missing, run.
      if (toggle && !toggle.checked) return;

      const cfg     = buildCfgLight();
      const preRows = buildPreRetRows(cfg);
      const preLast = preRows[preRows.length - 1] || null;

      let tBal  = preLast ? Number(preLast.End_Taxable || 0) : Number(cfg.taxable0 || 0);
      let fBal  = preLast ? Number(preLast.End_TFSA    || 0) : Number(cfg.tfsa0    || 0);
      let rBal  = preLast ? Number(preLast.End_RRSP    || 0) : Number(cfg.rrsp0    || 0);

      const rows   = [];
      let cumTaxOnTaxable = 0;

      const rAfter   = Math.max(0, cfg.return_rate_after || 0);
      const drag     = Math.max(0, Math.min(1, cfg.taxable_drag || 0));
      const gN       = 1 + rAfter;
      const gT       = 1 + rAfter * (1 - drag);
      const flatRate = Math.max(0, Math.min(0.90, cfg.income_tax_rate || 0));
      const br       = cfg.tax_brackets;
      const bracketsOn = !!(br && (br.enabled || br.bands));

      const lmRet = liqMap(cfg.asset_liquidations);

      const rAge   = Number.isFinite(cfg.retirement_age) ? cfg.retirement_age : (cfg.current_age || 0);
      const endAge = Number.isFinite(cfg.life_expectancy) && cfg.life_expectancy >= rAge ? cfg.life_expectancy : rAge;

      const ORDERS = ['TFR','TRF','FTR','FRT','RTF','RFT'];
      const FRACS = [0]; // (scan fractions if you re-enable TFSA prefill exploration)

      for (let age = rAge; age <= endAge; age++) {
        const openT = tBal, openF = fBal, openR = rBal;

        const oasGross = (age >= cfg.oas_start_age) ? oasGrossAtAge(cfg, age) : 0;

        const evalOrder = (order, tfsaNet) => {
          let guessRRSPGross = 0, lastRRSPGross = -1;
          let sim = null, oasClaw = 0, oasNet = oasGross;

          // iterate E with average taxable base: openT + 0.5 * (net RRIF-min deposited)
          let Einfo = computeTaxIncForOAS(openT, cfg);

          for (let it = 0; it < 3; it++) {
            if (oasGross > 0) {
              const baseIncomeForOAS = Math.max(0, cppAtAge(cfg, age) + guessRRSPGross + Math.max(0, Einfo.E || 0));
              const raw = Math.max(0, (baseIncomeForOAS - (cfg.oas_threshold || 0)) * (cfg.oas_clawback_rate || 0));
              oasClaw = Math.min(raw, oasGross);
              oasNet  = Math.max(0, oasGross - oasClaw);
            } else { oasClaw = 0; oasNet = 0; }

            sim = simulateYearOrderGivenOASNet({
              age, cfg, openT, openF, openR,
              oasGross, oasNet,
              order, tfsa_prefill_net: tfsaNet,
              lmRet, rAfter, drag, gN, gT, flatRate, br, bracketsOn
            });

            if (Math.abs(sim.fromRRSP_GROSS - lastRRSPGross) < 1) break;
            lastRRSPGross = guessRRSPGross;
            guessRRSPGross = sim.fromRRSP_GROSS;

            // recompute E using average taxable base including 0.5 * RRIF-min net added
            const addNetToTaxable = Math.max(0, sim.extraNetFromRRIFMin || 0);
            const avgBaseForE = openT + 0.5 * addNetToTaxable;
            Einfo = computeTaxIncForOAS(avgBaseForE, cfg);
          }

          const endTotal = (sim?.endTaxable || 0) + (sim?.endTFSA || 0) + (sim?.endRRSP || 0);
          return { sim, endTotal, oasClaw, oasNet, Einfo, EopenUsed: openT };
        };

        let best = null;
        for (const ord of ORDERS) {
          for (const frac of FRACS) {
            const r = evalOrder(ord, frac);
            const cand = { ...r, order: ord, tfsaNet: frac };
            if (!best || cand.endTotal > best.endTotal) best = cand;
          }
        }
        const chosen = best.sim;

        // advance balances
        tBal = chosen.endTaxable;
        fBal = chosen.endTFSA;
        rBal = chosen.endRRSP;

        const incomeTaxPayment = chosen.incomeTaxPayment;
        cumTaxOnTaxable += Math.round(chosen.taxOnTaxable);

        const cppBase   = Math.round(chosen.cppInc);
        const rrspBase  = Math.round(chosen.fromRRSP_GROSS);
        const taxIncE   = Math.round(best.Einfo.E || 0);
        const oasBase   = cppBase + rrspBase + taxIncE;
        const rawClaw   = (age >= cfg.oas_start_age)
                          ? Math.max(0, (oasBase - (cfg.oas_threshold || 0)) * (cfg.oas_clawback_rate || 0))
                          : 0;
        const clawCapped = (age >= cfg.oas_start_age) ? Math.min(rawClaw, oasGross) : 0;

        rows.push({
          Age: age,

          From_Taxable_Gross: Math.round(chosen.fromTax_GROSS_FOR_TABLE),
          From_TFSA: Math.round(chosen.fromTFSA),
          From_RRSP_Gross: Math.round(chosen.fromRRSP_GROSS),
          RRIF_Min_Pct: (chosen.rrifPct * 100).toFixed(2) + "%",

          OAS_Gross: Math.round(oasGross),
          OAS_Clawback: Math.round(clawCapped),
          OAS_Net: Math.round(Math.max(0, oasGross - clawCapped)),

          Tax_On_Taxable: Math.round(chosen.taxOnTaxable),
          Tax_On_RRSP: Math.round(chosen.taxOnRRSP),

          Liq_Added: Math.round(chosen.liq),
          Taxable_Drag: Math.round(chosen.taxDragAmt),   // display-only drag for the year

          // opening balances (debug)
          Open_Taxable: Math.round(openT),
          Open_TFSA: Math.round(openF),
          Open_RRSP: Math.round(openR),

          // OAS debug
          OAS_Base: oasBase,
          OAS_Base_CPP: cppBase,
          OAS_Base_RRSP: rrspBase,
          OAS_Base_TaxInc: taxIncE,
          OAS_TaxInc_Method: best.Einfo.method,
          OAS_TaxInc_openT: Math.round(best.EopenUsed),
          OAS_TaxInc_baseUsed: Math.round(best.Einfo.baseUsed ?? best.EopenUsed),
          OAS_TaxInc_rAfter: +(best.Einfo.rAfter || 0).toFixed(6),
          OAS_TaxInc_drag: +(cfg.taxable_drag || 0).toFixed(6),
          OAS_TaxInc_flat: +(best.Einfo.flat || 0).toFixed(6),
          OAS_Threshold: Math.round(cfg.oas_threshold || 0),
          OAS_Rate: +(cfg.oas_clawback_rate || 0).toFixed(3),
          OAS_Claw_raw: Math.round(rawClaw),
          OAS_Claw_capped: Math.round(clawCapped),

          End_Taxable: Math.round(tBal),
          End_TFSA: Math.round(fBal),
          End_RRSP: Math.round(rBal),
          End_Total_Raw: Math.round(Math.max(0, chosen.tAfter) + Math.max(0, chosen.fAfter) + Math.max(0, chosen.rAfterBal)),
          Cum_Tax_On_Taxable: Math.round(cumTaxOnTaxable),
          End_Total: Math.round(tBal + fBal + rBal),

          CPP: Math.round(chosen.cppInc),
          Living_Expense: Math.round(chosen.living),
          Income_Tax_Payment: incomeTaxPayment,
          Living_Exp_Ret: Math.round(Math.max(0, chosen.living - chosen.cppInc - Math.max(0, oasGross - clawCapped)) + incomeTaxPayment),
          Contrib_Taxable: 0, Contrib_TFSA: 0, Contrib_RRSP: 0
        });
      }

      const full = [...preRows, ...rows];
      window.__optRows = full;
      window.__optCfg  = cfg;

      const last = full[full.length - 1] || { Age: "—", End_Total: 0, Cum_Tax_On_Taxable: 0 };
      write("opt_summary",
        `End Total at age ${last.Age}: $${Number(last.End_Total || 0).toLocaleString()} (Tax on Taxable shown: $${Number(last.Cum_Tax_On_Taxable || 0).toLocaleString()}).`
      );

      const firstRet = rows.slice(0, 3);
      const r0 = firstRet.map(r =>
        `Age ${r.Age}: Open T=$${(r.Open_Taxable||0).toLocaleString()} | E=$${(r.OAS_Base_TaxInc||0).toLocaleString()} (${r.OAS_TaxInc_Method}) | OAS base=$${(r.OAS_Base||0).toLocaleString()} | Clawback=$${(r.OAS_Clawback||0).toLocaleString()}`
      ).join(" • ");
      write("opt_rationale", r0 || "See table for per-year mix.");

      if (!document.getElementById("opt_csv_btn")) {
        const btn = document.createElement("button");
        btn.id = "opt_csv_btn";
        btn.className = "btn btn-sm";
        btn.style.marginLeft = "8px";
        btn.textContent = "Download optimizer CSV";
        btn.onclick = () => {
          const csv = toCSV(window.__optRows || [], CSV_COLS);
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url; a.download = "optimized_withdrawals.csv";
          document.body.appendChild(a); a.click(); a.remove();
          URL.revokeObjectURL(url);
        };
        const host = pickEl("opt_summary", "#opt_summary");
        if (host?.parentElement) host.parentElement.appendChild(btn);
      }
    } catch (e) {
      const msg = (e && e.message) ? e.message : "JS";
      writeTo("opt_summary", "Optimizer error: " + msg);
      writeTo("opt_rationale", "");
      // console.error("Optimizer error:", e);
    }
  }

  // ---------------- wiring ----------------
  // Run when user clicks "Run plan" (if present) AND on load
  (function wire() {
    const runBtn = $("litev1_run");
    if (runBtn) runBtn.addEventListener("click", () => {
      try { nextDollar(); } catch(_) {}
      setTimeout(runOptimizerIfEnabled, 60);
    });

    const ids = [
      "oas_mo","oas_start_age","oas_threshold","oas_rate","rrif_start_age","litev1_income_tax",
      "tb_lim1","tb_lim2","tb_rate1","tb_rate2","tb_rate3","litev1_spend","litev1_return",
      "litev1_start_age","litev1_end_age","retirement_age",

      "cpp_monthly","cpp_support","support_cpp","support_monthly","living_expense_support","cpp_mo","cpp",
      "cpp_start_age","cpp_end_age","cpp_age_start","cpp_age_end","cpp_age","cpp_from_age","cpp_to_age",
      "extended_from_age","extended_to_age","ext_from_age","ext_to_age","extended_year_from","extended_year_to","ext_year_from_age","ext_year_to_age",

      "litev1_taxable","litev1_rrsp","litev1_tfsa","litev1_monthly_saving",
      "saving_increase_rate","annual_saving_increase_rate","annual_savings_increase_rate","savings_increase_rate","saving_increase","savings_increase",
      "pre_tfsa_annual","pre_rrsp_annual","return_rate_after","inflation_rate","litev1_taxable_drag",

      // E overrides
      "oas_tax_inc_fixed","oas_taxable_income_for_oas","oas_E","oas_tax_base_override","oas_E_base",

      "opt_toggle"
    ];
    ids.forEach(id => document.getElementById(id)?.addEventListener("input", () => {
      try { nextDollar(); } catch(_) {}
      runOptimizerIfEnabled();
    }));

    document.addEventListener("DOMContentLoaded", () => {
      try { nextDollar(); } catch(_) {}
      runOptimizerIfEnabled();
    });

    // Also kick once in case the page added the boxes after script load
    setTimeout(() => {
      try { nextDollar(); } catch(_) {}
      runOptimizerIfEnabled();
    }, 150);
  })();
})();
</script>
<!-- === /Optimizer (OAS gated/capped + E overrides + open-balance debug) ============== -->






























{% endblock %}



