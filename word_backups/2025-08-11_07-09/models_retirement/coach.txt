# models/retirement/coach.py
from __future__ import annotations
from typing import Dict, List, Any, Optional

# We import here to avoid circulars elsewhere and keep routes.py thin
from models.retirement.retirement_calc import (
    run_mc_with_seed,
    run_monte_carlo_simulation_locked_inputs as _MC,
)

def _first_depletion_age(series: Optional[List[float]], start_age: int) -> Optional[int]:
    """Return the first age where assets fall <= 0 (None if never)."""
    if not series:
        return None
    for i, v in enumerate(series):
        try:
            if v is not None and float(v) <= 0.0:
                return int(start_age + i)
        except Exception:
            continue
    return None

def _quick_mc(params: Dict[str, Any], n_sims: int = 600, seed: int = 12345) -> Dict[str, List[float]]:
    """Fast MC for testing patches (reuses your locked-inputs MC). Returns percentiles dict."""
    mc_params = dict(
        current_age=int(params["current_age"]),
        retirement_age=int(params["retirement_age"]),
        annual_saving=float(params["annual_saving"]),
        saving_increase_rate=float(params["saving_increase_rate"]),
        current_assets=float(params["current_assets"]),
        return_mean=float(params.get("return_mean", params["return_rate"])),
        return_mean_after=float(params.get("return_mean_after", params["return_rate_after"])),
        return_std=float(params["return_std"]),
        annual_expense=float(params["annual_expense"]),
        inflation_mean=float(params.get("inflation_mean", params["inflation_rate"])),
        inflation_std=float(params["inflation_std"]),
        cpp_monthly=float(params["cpp_monthly"]),
        cpp_start_age=int(params["cpp_start_age"]),
        cpp_end_age=int(params["cpp_end_age"]),
        asset_liquidations=list(params.get("asset_liquidations") or []),
        life_expectancy=int(params["life_expectancy"]),
        num_simulations=int(params.get("num_simulations", n_sims)),
        income_tax_rate=float(params["income_tax_rate"]),
    )
    out = run_mc_with_seed(seed, _MC, **mc_params)
    return out.get("percentiles", {})

def coach_suggestions(params: Dict[str, Any], percentiles: Dict[str, List[float]]) -> List[Dict[str, Any]]:
    """
    Return ranked suggestions with minimal patches aiming for p10>0 through horizon.
    Patches are client-friendly deltas you can apply to sliders/goals.
    """
    start_age = int(params.get("current_age", 50))
    p10 = percentiles.get("p10") or []
    horizon_ok = _first_depletion_age(p10, start_age) is None

    suggestions: List[Dict[str, Any]] = []

    # Status card (always first)
    status = "OK (≥90% success proxy)" if horizon_ok else "At risk (<90%)"
    at_age = None if horizon_ok else _first_depletion_age(p10, start_age)
    suggestions.append({
        "type": "status",
        "title": "Plan health",
        "detail": f"{status}" + (f" — depletion risk near age {at_age}" if at_age else "")
    })

    # If risk exists, search for small fixes
    if not horizon_ok:
        # 1) Minimal delay in retirement (≤5y)
        base = dict(params)
        for d in range(1, 6):
            try_params = dict(base, retirement_age=int(base["retirement_age"]) + d)
            pct_try = _quick_mc(try_params, n_sims=600)
            if _first_depletion_age(pct_try.get("p10") or [], start_age) is None:
                suggestions.append({
                    "type": "action",
                    "title": f"Delay retirement by {d} year(s)",
                    "why": "Raises success probability; worst-case (p10) stays above $0.",
                    "patch": {"retirement_age": int(base["retirement_age"]) + d}
                })
                break

        # 2) Trim annual spending in small steps (up to $12k/yr)
        step, max_cut = 3000, 12000
        for cut in range(step, max_cut + step, step):
            try_params = dict(params, annual_expense=max(0, float(params["annual_expense"]) - cut))
            pct_try = _quick_mc(try_params, n_sims=600)
            if _first_depletion_age(pct_try.get("p10") or [], start_age) is None:
                suggestions.append({
                    "type": "action",
                    "title": f"Trim spending by ${cut:,.0f}/yr",
                    "why": "Keeps the 10th percentile (p10) above $0 for the full horizon.",
                    "patch": {"annual_expense": float(params["annual_expense"]) - cut}
                })
                break

        # 3) Add a small part-time inflow for 3 years after retirement
        ra = int(params["retirement_age"])
        suggestions.append({
            "type": "action",
            "title": "Add part-time income $6,000/yr for 3 years post-retirement",
            "why": "Offsets early sequence risk in initial retirement years.",
            "patch": {"goal_events": [{
                "name": "part-time",
                "is_expense": False,
                "amount": 6000.0,
                "start_age": ra,
                "recurrence": "years",
                "years": 3,
                "inflation_linked": True
            }]}
        })

    # If already OK, add a stress test suggestion
    else:
        suggestions.append({
            "type": "action",
            "title": "Stress test: reduce returns by 1% (pre & post)",
            "why": "Check plan resilience under slightly worse markets.",
            "patch": {
                "return_rate": max(0.0, float(params["return_rate"]) - 0.01),
                "return_rate_after": max(0.0, float(params["return_rate_after"]) - 0.01),
                "return_mean": max(0.0, float(params.get("return_mean", params["return_rate"])) - 0.01),
                "return_mean_after": max(0.0, float(params.get("return_mean_after", params["return_rate_after"])) - 0.01),
            }
        })

    return suggestions
